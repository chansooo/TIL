# 9. Mathematics of Cryptography: Prime

비대칭키에서는 소수의 성질을 활용한다.

양의 정수는 다음으로 나눌 수 있다.

1. 숫자 1
    
    : 약수 = 1
    
2. 소수
    
    : 약수 = 2 (1과 자기자신)
    
3. 합성수 (Composite)
    
    : 약수 > 2
    

### 소수의 무한성 증명

소수가 유한으로 가정한다.

소수들의 집합 {2, 3, ..., p}, p는 가장 큰 소수. 로 이루어져 있을 것

N = 2*3*...*p에 대해서

N+1 > p 이므로 N+1은 소수가 아니다.

⇒ 소수의 곱으로 표시할 수 있으며 이중 하나를 q라고 하자.

그렇다면 N+1은 q의 배수이고 N도 q의 배수(N은 모든 소수의 곱이므로)이다.

그렇다면 N+1-N은 q의 배수여야 한다.

결국 1은 q의 배수여야 하므로 q=1인데,

1은 소수가 아니므로 모순이 발생한다.

⇒ 소수는 무한한다.

### 소수의 개수

$\pi(n)$

: n 이하의 소수의 개수

이를 구하는 식은 없다.

다만 상한과 하한을 증명되었으며,

큰 n에 대해서 근사는 할 수 있음

![스크린샷 2022-05-03 20.55.01.png](9%20Mathematics%20of%20Cryptography%20Prime%2082e647235ffb42ab90c36aae2a942782/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-05-03_20.55.01.png)

### 소수 판별 (Checking for Primeness)

$\sqrt{n}$ 보다 작은 소수들로 나눠지는지 확인해본다.

⇒ 해당하는 모든 소수로 안나눠지면 소수다!

## 오일러 파이 함수 (Euler’s Phi-Function)

---

![스크린샷 2022-05-03 21.20.57.png](9%20Mathematics%20of%20Cryptography%20Prime%2082e647235ffb42ab90c36aae2a942782/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-05-03_21.20.57.png)

$\phi(n)$ 

: n보다 작으면서 n과 서로소인 양의 정수의 개수

여기서 e는 자연상수아니고 그냥 exponential의 약자

![스크린샷 2022-05-03 21.02.09.png](9%20Mathematics%20of%20Cryptography%20Prime%2082e647235ffb42ab90c36aae2a942782/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-05-03_21.02.09.png)

- 증명: 3번
    
    가정: m≠n이고, m, n은 소수
    
    $\phi(mn)$ 을 구하기 위해서는 [1, mn-1] 중에서 mn과 서로소가 아닌 것들을 모두 빼면 된다.
    
    m의 배수: m, 2m, ..., (n-1)m → mn과 서로소가 아니니까 뺀다. (n-1개)
    
    n의 배수: n, 2n, 3n, ..., (m-1)n → mn과 서로소가 아니니까 뺀다. (m-1개)
    
    mn-1-(n-1)-(m-1)=mn-m-n+1=(m-1)(n-1)=$\phi(m)\phi(n)$
    
- 증명: 4번
    
    가정: e는 양의 정수
    
    [1, p^e -1] 중에서 p^e와 서로소가 아닌 것들을 모두 빼면 된다.
    
    p의 배수: p, 2p, ..., $p^{e-1}p$ → p^e와 서로소가 아니니까 뺀다.
    
    $p^e-1-(p^{e-1}-1)=p^e-p^{e-1}$
    

$\phi(n)$을 계산하기 위해서 

n은 다음과 같이 소수의 곱으로 나타낼 수 있다. (소인수분해 형태)

![스크린샷 2022-05-03 21.14.46.png](9%20Mathematics%20of%20Cryptography%20Prime%2082e647235ffb42ab90c36aae2a942782/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-05-03_21.14.46.png)

성질 3에 의해서 각 소수들은 모두 서로소이므로 다음처럼 분리할 수 있음

![스크린샷 2022-05-03 21.16.29.png](9%20Mathematics%20of%20Cryptography%20Prime%2082e647235ffb42ab90c36aae2a942782/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-05-03_21.16.29.png)

그러면 성질 4에 의해서 다음과 같이 만들 수 있음

![스크린샷 2022-05-03 21.16.49.png](9%20Mathematics%20of%20Cryptography%20Prime%2082e647235ffb42ab90c36aae2a942782/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-05-03_21.16.49.png)

- 예제
    
    ![스크린샷 2022-05-03 21.18.14.png](9%20Mathematics%20of%20Cryptography%20Prime%2082e647235ffb42ab90c36aae2a942782/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-05-03_21.18.14.png)
    
    ![스크린샷 2022-05-03 21.18.25.png](9%20Mathematics%20of%20Cryptography%20Prime%2082e647235ffb42ab90c36aae2a942782/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-05-03_21.18.25.png)
    
    이와 같은 경우 7과 7은 서로소가 아니므로, 주의할 것
    

## 페르마의 소정리 (Fermat’s Little Theorem)

---

### First Version

p는 소수, a는 정수, a가 p의 배수가 아닐 때(나눠지지 않을 때)

$$
a^{p-1}mod\space p=1
$$

### 증명

집합 A = {1, 2, ..., p-1}

집합 B = {a mod p, 2a mod p, ..., (p-1)a mod p} 

: A에서 원소에 a를 곱하고 mod p를 취한 것

일 때 A=B임을 보이려고 한다.

1. 만약 B에 0이 없고
2. B의 모든 원소가 각각 다르다면
    
    A=B일 것이다. 
    

2에 대해 증명

가정: ia mod p = ja mod p (i≤i<j≤p-1 일 때)

(j-i)a=kp 인 k가 있다.

이 때 j-i<p 이고, p는 a로 나눠지지 않으므로, 이를 만족하는 k는 0밖에 없다.

그렇다면 j-i=0이어야 하는데 모순 발생!!

⇒ A = B

(B에도 1 ~ p-1의 숫자들이 들어있다)

그렇다면..

A, B 각 집합에 대해 모든 원소를 곱했을 때

1*2*...*(p-1) = (a mod p) * (2a mod p) * ... * ((p-1)a mod p)

양변에 mod p를 해주고, 양변에 1*2*...*(p-1)을 나눠주면

$1=a^{p-1}mod\space p$

- 예제
    
    ![스크린샷 2022-05-03 21.39.44.png](9%20Mathematics%20of%20Cryptography%20Prime%2082e647235ffb42ab90c36aae2a942782/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-05-03_21.39.44.png)
    

### Second Version

p가 소수, a가 정수일 때

![스크린샷 2022-05-03 21.40.33.png](9%20Mathematics%20of%20Cryptography%20Prime%2082e647235ffb42ab90c36aae2a942782/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-05-03_21.40.33.png)

### 증명

1. a가 p로 나눠지지 않을 때
    
    first version과 같아진다.
    
    양변에 a mod p를 곱하면 됨
    
2. a가 p로 나눠질 때
    
    a mod p = 0
    
    a^p mod p  = a mod p = 0이므로 성립
    

### 곱셈역 구하기

p가 소수, 0<a<p일 때

second version을 이용해서 

$a^{-1}mod\space p = a^{p-2}mod\space p$

- 예제
    
    ![스크린샷 2022-05-03 22.14.14.png](9%20Mathematics%20of%20Cryptography%20Prime%2082e647235ffb42ab90c36aae2a942782/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-05-03_22.14.14.png)
    
    p가 소수인 경우에는 유클리드 알고리즘 대신 지수 계산을 통해 구할 수 있다.
    

## 오일러 정리 (Euler’s Theorem)

---

a와 n이 서로소일 때

$$
a^{\phi(n)}mod\space n=1
$$

⇒ 이 때 n이 소수이면 페르마의 소정리와 같음

(소수이면 $\phi(n)=n-1$  이므로)

## 소수 생성 (Generating Primes)

---

### Mersenne Primes

- **Mersenne numer** $M_p$
    
    = $2^p-1$
    

이 때 소수 p에 대해 Mp가 소수인지 본다.

![스크린샷 2022-05-03 22.23.30.png](9%20Mathematics%20of%20Cryptography%20Prime%2082e647235ffb42ab90c36aae2a942782/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-05-03_22.23.30.png)

2~17까지 소수 중에서는 11 빼고는 Mp가 소수네

그런데 11처럼 소수가 안나오는 애들 많아서 이걸로 소수를 구하는 건x

현재까지 mersenne prime은 51번째까지 찾음 (p=82,589,933)

이런 방법으로 컴퓨터를 이용해서 매우 큰 소수들을 하나씩 찾고 있음 

GIMPS (Great Internet Mersenne Prime Search) 프로젝트에서는 분산처리를 이용해서 다음 Mersenne prime을 계속 찾고 있다..

이 때 분산처리이기 때문에 다음 발견되는 Mp가 더 크다는 보장이 없음 (더 작은 Mp가 뒤에 발견될 수도 있음)

이는 부하가 많이 발생해서 system stress testing에도 사용된다.