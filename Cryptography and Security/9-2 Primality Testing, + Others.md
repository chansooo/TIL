# 9-2. Primality Testing, + Others

### Divisibility Algorithm

![스크린샷 2022-05-10 21.01.50.png](9-2%20Primality%20Testing,%20+%20Others%20c7b5402d87864b989b2c69c00d186085/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-05-10_21.01.50.png)

루트 n보다 작은 수에 대해 하나씩 다 나눠보면서

나눠지는게 있다 → composite

없다 → prime

- 알고리즘 수행시간 분석
    
    $n_b$ 개의 비트로 이루어진 수 n은 $2^{n_b}$의 크기를 가진다.
    
    따라서 평균적으로 $\sqrt2^{n_b}$ 번의 나눗셈이 필요하다.
    

## Probabilistic Algorithm

---

확률적으로 소수 판별을 진행한다.

![스크린샷 2022-05-10 21.14.51.png](9-2%20Primality%20Testing,%20+%20Others%20c7b5402d87864b989b2c69c00d186085/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-05-10_21.14.51.png)

이 알고리즘은 입력이

소수일 때 확실하게 판별하지만,

합성수일 때 적은 비율 ($\epsilon$)만큼 오류가 발생한다.

⇒  판단이 composite이면 확실하게 composite가 맞는데,

판단이 prime이면 100%맞는 것은 아니다 (사실 composite일 수 있음)

이러한 조건을 찾기 위해서 페르마의 소정리 (fermat’s little theorem)을 이용해본다.

### Fermat test (페르마 테스트)

- 페르마의 소정리
    
    소수 p와 정수 a에 대해 p가 a로 나눠지지 않으면, a^(p-1) mod p = 1이다
    

> n이 소수이면 a^(n-1) mod n = 1 (1<a<n) 이다.
> 

이것을 이용해서

1. a^(n-1) mod n ≠ 1 (1<a<n)일 때 n은 합성수이다.
    
    ⇒ 항상 확실함 (대우 명제)
    
2. a^(n-1) mod n = 1 (1<a<n) 일 때 n은 소수일 것이다. (추측)
    
    ⇒ 추측이며 확실하지 않음
    

따라서 [2, n-2] 범위의 정수 중에서 임의로 a를 골라서 위의 테스트를 진행한다.

> a가 n-1일 때는 (n-1)^2 mod n = 1이므로 거듭제곱을 해도 항상 1이 나오므로 제외한다.
> 
- 1이 아니다: composite라고 판단 → 100프로 확실
- 여러번 해봤는데 1이다: prime으로 판단 → 확실하지는 않지만, 높은 확률로 맞음

여러번 하는 횟수가 늘어날 수록 오차 확률은 줄어든다.

### Square Root test

![스크린샷 2022-05-10 21.32.58.png](9-2%20Primality%20Testing,%20+%20Others%20c7b5402d87864b989b2c69c00d186085/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-05-10_21.32.58.png)

- 예제
    
    ![스크린샷 2022-05-10 21.33.35.png](9-2%20Primality%20Testing,%20+%20Others%20c7b5402d87864b989b2c69c00d186085/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-05-10_21.33.35.png)
    

1, n-1은 항상 들어간다.

만약 n이 소수일 때 $\sqrt1 mod \space n=\{1,n-1\}$

 $\sqrt1 mod \space n$ ≠ $\{1,n-1\}$ 

⇒ composite

하지만, {1, n-1}이라고 해서 prime은 아니다 (예 = 22)

⇒ 역은 성립안한다!!

### Miller-Rabin Test

: Fermat test(기본) + Square Root test(보조)

1. 페르마 테스트를 위해 [2, n-2] 범위의 정수 a를 랜덤하게 선택한다.
2. n-1이 짝수이므로 홀수가 될 때까지 2로 나눈다. 이 때 나온 홀수를 m이라고 한다.
    
    > n-1이 홀수이면 n은 짝수인데.. 그러면 굳이 테스트할 필요가 없겠네?
    > 
    
    ![스크린샷 2022-05-10 21.45.34.png](9-2%20Primality%20Testing,%20+%20Others%20c7b5402d87864b989b2c69c00d186085/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-05-10_21.45.34.png)
    
3. a^(n-1)을 계산하기 위해서 $a^mmod\space n$을 먼저 계산하고, 계속 제곱해서 구한다.
    
    = 분할정복으로 거듭제곱을 구하는 것임
    

![스크린샷 2022-05-10 21.46.19.png](9-2%20Primality%20Testing,%20+%20Others%20c7b5402d87864b989b2c69c00d186085/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-05-10_21.46.19.png)

1. 이 때 제곱해서 mod n을 하는 과정이 square root test죠?
    
    ⇒ 메인으로 페르마 테스트인데, 제곱근 테스트도 함께 진행한다.
    

- 알고리즘
    
    ![스크린샷 2022-05-10 21.50.50.png](9-2%20Primality%20Testing,%20+%20Others%20c7b5402d87864b989b2c69c00d186085/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-05-10_21.50.50.png)
    
    T ≠ 1, T ≠ n-1인 상태에서 
    
    T^2 mod n = 1
    
    ⇒ T^2 ≠ 1, T^2 ≠ n-1인데 mod n = 1 이므로 Square Root test에 의해 합성수이다.
    
    왜냐? x^2 mod n = 1을 만족하는 x가 1과 n-1만 있어야 되므로!!
    
    T^2 mod n = n-1
    
    ⇒ 앞으로 거듭제곱을 해서 mod n을 해도 항상 1이 나오므로 페르마 테스트 조건에 의해 소수이다.
    
    for 루프가 다돈 후의 상태에서
    
    ![스크린샷 2022-05-10 22.05.19.png](9-2%20Primality%20Testing,%20+%20Others%20c7b5402d87864b989b2c69c00d186085/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-05-10_22.05.19.png)
    
    1. T^2 mod n = 1이면
        
        square root test에 의해 composite이다.
        
    2. T^2 mod n ≠ 1이면
        
        $a^{n-1} mod\space n$ ≠ 1이므로, 페르마 테스트에 의해 composite이다.
        
    
    ⇒ 따라서 for 다돈 상태에서는 무조건 composite이다.
    
- 예제
    
    ![스크린샷 2022-05-10 22.08.31.png](9-2%20Primality%20Testing,%20+%20Others%20c7b5402d87864b989b2c69c00d186085/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-05-10_22.08.31.png)
    
- **liar**
    
    : composite인데 prime이라고 잘못 판단하게 만드는 a 값
    

이 때 랜덤하게 선택된 a가 liar일 확률은 1/4 이하이다.

따라서 10개의 a를 선택해서 miller-rabin 알고리즘을 10번 돌리면

composite를 prime으로 판단할 확률은 (1/4)^10 이하이다.

### 권장하는 소수 테스트 방법

1. n은 홀수여야 함
2. 잘 알려진 작은 소수들(3, 5, 7, 11, 13 ...)로 divisibility test를 먼저 진행
3. 10개의 base (a)를 랜덤하게 선택한다.
4. 각 base에 대해 Miller-Rabin을 돌려서 하나라도 composite이면 해당 판별은 끝. (step 1으로 가서 다른 홀수를 찾아본다)
    
    base 10개에 대해 다 통과하면 prime으로 판별
    

## 9-3. Factorization

---

흔히 말하는 소인수분해가 prime factorization인데,

아주 큰 정수 n의 소인수분해는 어렵다

(불가능한 것은 아닌데, 시간이 오래 걸린다)

![스크린샷 2022-05-10 22.19.54.png](9-2%20Primality%20Testing,%20+%20Others%20c7b5402d87864b989b2c69c00d186085/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-05-10_22.19.54.png)

## 9-6. Exponentiation and Logarithm

---

![스크린샷 2022-05-10 22.21.14.png](9-2%20Primality%20Testing,%20+%20Others%20c7b5402d87864b989b2c69c00d186085/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-05-10_22.21.14.png)

지수 계산을 빨리하는 알고리즘

square and multiply

![스크린샷 2022-05-10 22.23.06.png](9-2%20Primality%20Testing,%20+%20Others%20c7b5402d87864b989b2c69c00d186085/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-05-10_22.23.06.png)

x를 이진법으로 나타낸 다음에 분할정복을 이용해서 계산한다.

![스크린샷 2022-05-10 22.24.27.png](9-2%20Primality%20Testing,%20+%20Others%20c7b5402d87864b989b2c69c00d186085/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-05-10_22.24.27.png)

따라서 for 루프는 x를 이진법으로 나타냈을 때 비트수만큼 수행된다.

x = 22일 때, 10110 → 5bit이므로 5번만 돌면 된다!

이말은 log2한만큼 수행된다고 보면 되겠네용.. 걍 분할정복이다~!!