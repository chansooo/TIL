# Ch 10-2. Real-Time Scheduling

### Real-Time System

RT 시스템에서는 RT-OS 스케줄러가 중요한 요소이다.

- 예시 : 연구실 실험 제어, 산업 현장의 공정 제어, 로봇 공학, 항공 교통 관제, 군사 지휘 시스템
- RT 시스템에서는 계산의 논리적인 계산 결과 뿐만 아니라 결과가 생성되는 **시간**의 정확성도 중요하다.
    
    ex) 자율 주행 시스템에서 판단의 정확성 뿐만 아니라 판단된 시간도 중요하다.
    
- 프로세스는 외부 세계에서 실시간으로 발생하는 이벤트에 대응해야 한다.
- RT 시스템에서 핵심은 short-term (단기) task 스케줄러이다.
    - 공정성과 평균 응답 시간 최소화가 중요한 것이 아니다.
        
        ex) 급정거 vs 창문 내리기. 만약 공정하게 한다면..? 
        
    - 따라서 
    중요한 일 (hard-real-time task)을 deadline 안에 반드시 완료한 이후
    덜 중요한 일(soft real-time task)을 deadline 안에 진행한다

### Hard and Soft Real-Time Tasks

- Hard real-time task : 반드시 deadline 안에 처리해야 하는 일. 그렇지 않으면 치명적인 손상이나 오류가 발생
- Soft real-time task : 필수는 아닌 Deadline이 있다. → ASAP 정도로만

### Periodic(주기적) and Aperiodic(비주기적) Tasks

- Periodic tasks(주기적) : 일정한 period나 interval을 가진다.
    - 기간 T안에 한 번
    - T마다 주기적으로 반복 (인터벌)
- Aperiodic tasks(비주기적) : 언제 발생할지는 모르지만 시작 또는 종료에 대한 deadline이 있다.

### 대부분 RT OS에서 사용하는 특성

- 실시간 요구사항을 만족하기 위해서 선점형 스케줄링을 사용한다.
- 일반적인 OS보다 **우선순위를 엄격**하게 사용한다.

- 인터럽트 latency(지연 시간)이 제한적이고 짧게 설정되어 있다.

- 일반적인 OS보다 시간에 관련된 것들을 정확하게 예측가능하도록 한다.

## RT 시스템의 특징

---

### 1. Determinism (결정성) - 빠른 반응속도.. 빠르게 그 서비스를 시작. Delay를 줄여야함. 얼마나 빠르게 알아차리느냐?(처리전)

- OS가 결정적이다 : 작업을 수행함에 있어서 미리 결정된 고정된 시간 또는 인터벌 내에 어떤 기능을 완료해줄 수 있다는 것을 의미.
- 결정성은 인터럽트가 발생하고 OS가 이에 대한 서비스를 시작할 때까지의 최대 지연시간과 연관성 크다.
    - non RT OS에서는 delay ≤ 2~3초
    - RT OS에서는 delay ≤ 1ms
    - Real Time에서는 상당히 빠르게 반응해야한다.
- OS의 결정성의 요인
    - 인터럽트에 응답할 수 있는 속도(얼마나 빠르게 답변하느냐)
    - 시스템에 필요한 시간 내에 모든 요청을 처리할 수 있는 충분한 자원이 있는지 여부

### 2. Responsiveness (반응성) - 알아차리고 난 다음 얼마나 빠르게 수행하는지(처리후)

- OS가 인터럽트를 알아차린 후 서비스를 처리하는데 걸리는 시간
- 결정성 + 반응성 = 외부 이벤트에 대한 응답 시간

- 반응성에 포함되는 요소(ISP : interrupt 서비스 루틴)
    - 인터럽트를 처음 감지하고 인터럽트 서비스 루틴(ISR) 실행을 시작하는데 필요한 시간
    - ISR을 수행하는데 걸리는 시간
    - 인트럽트 중첩으로 인한 서비스 딜레이
        
        ( ISR 도중에 발생한 지연)
        

### 3. User Control

- 일반적인 OS보다 훨씬 더 광범위한 user control이 허용된다.
    
    (OS는 해당 기능이 반응성이 얼마나 중요한지 알 수가 없기 때문)
    
- User가 hard task인지 soft task인지 구분할 수 있어야 한다.
- User가 작업 우선순위에 대해 세밀하게 제어할 수 있도록 허용한다.(존나 많은 권한을 User에게 준다)
    - 페이징을 사용할 것인지?
    - 프로세스 스와핑을 할 것인지?
    - 메모리에 상주할 프로세스는 무엇인지?
    - 디스크 전송 알고리즘은 무엇을 사용할 것인지?
    - 우선순위 band에 속한 프로세스에게 어떤 권한을 부여할 것인지?

### 4. Reliability (신뢰성)

- RT 시스템에서는 훨씬 중요하다.
    - non RT 시스템에서는 문제가 발생해도 재부팅하면 된다.
    - RT 시스템에서는 실시간 이벤트에 응답하고 제어해야 하기 때문에 성능 손실이나 저하가 되면 심각한 피해를 야기할 수 있다.
        - ex) 재정적 손실, 중요 장비 손상, 인명 피해

### 5. Fail-Soft Operation(안전성)

- 실패해도 최대한 손실이 적게 보존한다.
    - 실패 → RT 시스템은 수정을 시도 → 감소된 서비스 수준에서 작업을 계속
        
        ex) 고화질 영상 재생 중 네트워크 대역폭 부족 → 저화질로 변경해서 재생
        
    - 만약 종료되어야 한다면 파일이나 데이터를 저장해서 일관성을 유지한다.
        
        ex) 종료된 부분부터 다시 재생할 수 있도록
        
- 중요한 관점 : 안정성 : 높은 우선순위를 가진 작업은 꼭 Deadline안에 수행 될 수 있도록 하는 것.
    - 높은 우선순위를 가진 작업은 항상 deadline 안에 수행되도록 (낮은 것은 항상 충족되지는 못하더라도 괜찮음)

### RT 시스템의 스케줄러

- RR 선점 스케줄러 : 새로운 것이 들어오면 맨뒤로 들어감. 우선순위가 높아도 맨 뒤로 가버리니까 존나 기다려야함. → 문제 발생!!!!! 절대 RT에서는 쓰면 안됨XXXXXXX
- 우선순위 기반 비선점 스케줄러 : 현재 실행중인 프로세스가 종료되거나 Block될때까지 또 기다려야함 안돼!!!!!!!!!!XXXX
- 우선순위 기반 비선점 스케줄러 + 선점 지점(Check point)
    
    : 선점 포인트마다 우선순위를 확인해서 자신보다 높은 우선순위가 있으면 선점
    
    : 되긴하는데 좀 덜 급한 Soft한 Real Time에서는 사용가능하다!
    
    → soft RT 시스템에서는 사용 가능
    
- 즉각적인 선점 스케줄러 (Immediate preemptive)
    
    : 인터럽트에 거의 즉시 응답한다.
    
    : 들어오자마자 바로 반응해서 RT에서 아주 좋다.
    
    → hard RT 시스템에서 사용 가능
    
    - 100microsecond 이하로 지연되어야 한다.

## Real-Time Scheduling(실시간 스케줄링)

---

- 스케줄링 고려사항
    1. Schedulability Analysis : 스케줄 가능한 것이 있는지?
        
        → Statically or Dynamically
        
    2. 분석 결과에 따른 판단

### RT 스케줄링 알고리즘의 4가지 접근

1. [**정적] 테이블 기반 (Static table-driven) - 시작 전에 스케줄을 만든다.**
    - 스케줄할 수 있는지 정적 분석을 수행
    - task가 실행되는 시간(런타임 시간)을 결정 → 스케줄을 만든다.
    
    - **주기적인 task**에 적합하다
        
        → 미리 분석을 해놨기 때문에 예측은 하기 쉽다, But Task 요구사항을 변경하려면 스케줄을 다시 만들어야 하므로 유연성이 없다.
        
    
    ---
    
2. [**정적] 우선순위 기반 (Static Priority-Driven) 선점**
    - 정적으로 분석은 하지만 schedule은 만들어 내지 않는다.
    - 분석하여 task에 우선순위만 준다
    - 우선순위에 따라서 나중에 돌아가게끔 하는 방식이다.
    
    - Task의 시간 제약조건에 따라 우선순위를 부여한다.
        
        (시간 제약이 짧은지/긴지에 따라서 우선순위를 부여.)
        
    
    ---
    
3. [**동적] 계획 기반 (Dynamic planning-based) - 시작 후에 스케줄을 만든다.**
    - offline이 아닌, run time에 분석한다.
    - 언제 dispatch될 것인지 계획과 스케줄의 결과를 만든다.
    
    - Task가 도착을 했을 때 바로 수행시키는것이 아니라 분석 후 스케줄을 시킨다.
    - 기존 Task와 새로운(새로 도착한) Task 모두 Deadline을 지킬 수 있을 때 스케줄을 수정한다
    - 기존의 놈들, 새로운 놈 모두 Deadline을 지킬 수 있을 때만!! 스케줄을 수정한다.
    
    ---
    
4. [**동적] 최선의 노력 (Dynamic Best Effort)**
    - 분석을 하지 않는다ㅋㅋ
    - deadline을 만족하기 위해서 계속 노력한다.
    - deadline을 넘긴 프로세스는 중단시킨다.

- 많은 상용 RT 시스템에서 사용한다.
- Task가 도착하면 해당 특성에 따라 시스템이 우선순위를 할당한다.
- 일반적으로 Task는 비주기적이므로 정적으로 스케줄 분석을 할 수 없기 때문에 사용한다.
- 장단점
    - 구현하기 쉽다
    - deadline을 지킬 수 있을지 미리 예측할 수 없다.

## Deadline Scehduling

---

- 대부분 RT OS의 설계 목표
    
    : 신속한 인터럽트 처리 및 Task 디스패치를 통해 실시간 작업을 최대한 빠르게 시작한다.
    
- RT 애플리케이션은 무조건 속도만 고려하는 것이 아니라, 가장 가치 있는 시간에 작업을 완료하는데 관심을 가진다.
    
    → 단순히 우선순위에 의한 선점만 할 것이 아니라 가장 가치 있는 시간에 완료하기 위한 다양한 요구사항을 만족해야 한다.
    

### Deadline Scheduling에 사용되는 정보들

- Ready time : 작업을 실행할 준비가 완료되는 시점.
- Starting deadline : 작업을 시작해야 하는 시간(deadline)
- Completion deadline : 작업을 완료해야 하는 시간(deadline)
- Processing time : 작업이 완료될 때까지 실행에 필요한 시간
- Resource requirements : 작업이 실행되는 동안 필요한 리소스 집합
- Priority : 작업의 상대적 중요성
    - hard RT 작업은 절대적 우선순위를 가질 수 있다.
- Subtask scheduler : 작업을 필수(madatory) 하위 작업과 선택적(optional) 하위 작업으로 분해할 수 있다.
    - 필수 하위 작업만 Hard deadline을 가진다.
    - Optional 하위 작업은 굳이 Deadline을 안가진다.
    

### 예시) Completion Deadline이 있는 주기적인 작업 스케줄링

주기적 → 언제 들어올지 미리 알 수 있다.

![스크린샷 2022-06-12 00.03.44.png](Ch%2010-2%20Real-Time%20Scheduling%2096101df39d0e486f896330a5fce5c9ab/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-06-12_00.03.44.png)

- 두 센서 A, B에서 데이터를 수집하고 처리한다.
- Deadline : A=20ms, B=50ms (자료를 수집해야하는 Deadline)
- 데이터 처리 시간 : A=10ms, B=25ms

![스크린샷 2022-06-12 00.06.47.png](Ch%2010-2%20Real-Time%20Scheduling%2096101df39d0e486f896330a5fce5c9ab/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-06-12_00.06.47.png)

- A가 B보다 우선순위가 높다면 : B1은 missed (= Deadline을 넘김)
- B가 A보다 우선순위가 높다면 : A1, A4 missed
- deadline이 빨리 마감되는 것에 우선순위 : 모두 deadline 안에 완료하였다!!

### 예시) Starting deadline이 있는 비주기적인 작업 스케줄링

비주기적 → 작업이 언제 들어올지 미리 알 수 없다.

![스크린샷 2022-06-12 00.12.39.png](Ch%2010-2%20Real-Time%20Scheduling%2096101df39d0e486f896330a5fce5c9ab/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-06-12_00.12.39.png)

> 한 번 시작되면 완료될 때까지 실행해야 한다.
> 

- **가장 빠른 데드라인 (Earliest deadline)**
    
    B가 들어왔을 때 A가 이미 실행중이므로 deadline을 지키지 못하는 경우가 발생한다.
    
- **강제되지 않는 Idle 시간을 가지는 가장 빠른 데드라인 (Earliest deadline with unforced idle times)**
    
    데드라인을 지킬 수 있는 선에서 적격한 작업 요청이 올 때까지 기다려본다(일단 기다려보는거야~).
    
    → 프로세서 효율은 떨어지더라도 스케줄링 요구사항을 만족시킬 수 있다.
    

![스크린샷 2022-06-12 00.18.32.png](Ch%2010-2%20Real-Time%20Scheduling%2096101df39d0e486f896330a5fce5c9ab/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-06-12_00.18.32.png)

긴 deadline을 가진 프로세스 A는 unforced idle time을 가지면서 다른 중요한 작업을 먼저 수행켜서 모든 deadline을 만족할 수 있다.

## Rate Monotonic(단조) Scheduling (RMS)

---

작업의 주기(period)를 기반으로 우선순위를 할당한다.

주기가 짧은 놈일 수록 높은 우선순위를 주겠다.

![스크린샷 2022-06-12 01.01.35.png](Ch%2010-2%20Real-Time%20Scheduling%2096101df39d0e486f896330a5fce5c9ab/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-06-12_01.01.35.png)

- 주기가 짧을수록 빈도는 높다 → 높은 우선순위를 할당한다

![스크린샷 2022-06-12 01.03.35.png](Ch%2010-2%20Real-Time%20Scheduling%2096101df39d0e486f896330a5fce5c9ab/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-06-12_01.03.35.png)

- C = 실행시간, T = 해당 작업의 period
- P의 주기동안의 프로세서 활용도 = $u_P = \frac{C}{T}$ → 1보다 클수가 없다!! 주기보다 실행시간이 길순 없어
- RMS를 만족하는 n개의 작업 (upper bound)
    
    ![스크린샷 2022-06-12 01.07.13.png](Ch%2010-2%20Real-Time%20Scheduling%2096101df39d0e486f896330a5fce5c9ab/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-06-12_01.07.13.png)
    
    이 수식을 벗어나면 RMS를 만족하지 않는다.(스케줄러가 실시간 스케줄을 못하는거임)
    

![Task들의 정보 및 도착한 시간](Ch%2010-2%20Real-Time%20Scheduling%2096101df39d0e486f896330a5fce5c9ab/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-06-12_01.08.08.png)

Task들의 정보 및 도착한 시간

- Task Ti = (period P, execution time C)
- 우선순위 : T1 > T2 > T3

![스크린샷 2022-06-12 01.08.23.png](Ch%2010-2%20Real-Time%20Scheduling%2096101df39d0e486f896330a5fce5c9ab/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-06-12_01.08.23.png)

- T3의 1a가 수행중 우선순위가 높은 T1의 주기가 돌아왔다.(3a가 아니라 2a임)
- T1이 끝나니 T2의 주기가 돌아왔다.
- T2까지 끝나니 T3는 miss가 발생했다.
    
    → 왜 안될까? 이후 나오는 RMS Upper bound 테이블을 참고
    

- RMS Upper bound 테이블
    
    ![스크린샷 2022-06-12 01.14.13.png](Ch%2010-2%20Real-Time%20Scheduling%2096101df39d0e486f896330a5fce5c9ab/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-06-12_01.14.13.png)
    

앞의 수식을 계산해보면

(1/4 + 2/5 + 2/7) == 0.936

n = 3이므로 테이블에 의해 upper bound는 0.779(더한것이 upper bound보다 작아야 스케줄가능)

⇒ upper bound를 넘었네? RMS로 스케줄할 수 없는 작업들이다!!

### Priority Inversion (우선순위 역전)

: 시스템의 상황에 따라서 우선순위가 높은 작업이 낮은 작업을 기다리는 현상

- **Unbounded Priority Inversion**
    
    : 공유 자원을 접근하기 위해서 무작정 기다리게 된다.
    

![스크린샷 2022-06-12 01.19.45.png](Ch%2010-2%20Real-Time%20Scheduling%2096101df39d0e486f896330a5fce5c9ab/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-06-12_01.19.45.png)

- 우선순위 : T1 > T2 > T3
- T3가 먼저 실행 중 자원 s에 대한 lock을 건 상태
- T1은 s에 접근을 기다리면서 T3에 의해 블락된 상태
- 이 때 T3보다 우선순위가 높은 T2가 도착해서 실행하면서 T1보다 먼저 스케줄링 된다!
    
    ⇒ 만약 이러한 상황이 연속적으로 일어나면 T1은 우선순위가 높음에도 무기한 연기될 것이다.
    
- 예시) 화성 탐사선 사례
    - T3는 주기적으로 장비를 테스트하는 작업
    - T1은 주기적으로 시스템이 잘 작동하는지(건강한지) 확인해서 (deadline 넘기는) 문제가 발생하면 시스템을 초기화하는 작업, 근데 T3가 장비를 선점하고 있어서 T1이 대기하고 T2가 사진을 막 찍게된거임. 그래서 시간이 계속 지나버리니 문제가 없는데도 계속 시스템을 초기화시켜버렸음.
    - T2는 이미지에 대한 작업
        
        ⇒ T1이 무기한 지연되면서 계속 시스템이 초기화된 것이다.
        

### Priority Inheritance (우선순위 상속)

: 우선순위가 낮은 작업은 공유 자원에서 보류 중인 더 높은 우선순위 작업의 우선순위를 상속한다

→ 우선순위 역전 문제를 해결

![스크린샷 2022-06-12 01.29.03.png](Ch%2010-2%20Real-Time%20Scheduling%2096101df39d0e486f896330a5fce5c9ab/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-06-12_01.29.03.png)

- T1이 블락되었을 때 T3은 T1의 우선순위를 상속받는다.
    
    → T2가 도착해도 T3의 우선순위에 의해 T1이 실행될 때까지 T2이 실행되지 않는다
    
    ⇒ T1의 무기한 연기를 방지할 수 있다.