# 9. Uniprocessor Scheduling (1)

> by chansooo
> 

# **단일처리기 스케줄링**

## 스케줄링이란?

- 스케줄링은 멀티프로그래밍을 지원하는데 있어서 아주 Key다.
- 스케줄링이 제대로 안되면 멀티프로그래밍을 잘 실행할 수 없음.
- 스케줄링 : 프로세스들이 일생 동안 각종 대기 큐에서 대기하는 시간을 얼마나 줄이느냐.

## **처리기 스케줄링의 유형**

- 처리기 스케줄링의 정의
    - 응답 시간이나 처리량, 효율성을 증대시키기 위해 처리기가 다음에 실행할 프로세스를 선택하는 것
- 선후 관계에 따른 스케줄링의 유형
    - 장기 스케줄링 : Degree of Multiprogramming을 결정
    - 중기 스케줄링 : Swapper의 역할(메인메모리에 Swap-in or Swap-out 하는 것을 결정)
    - **단기 스케줄링 : 대기 큐에 있는 프로세스 중 다음에 실행할 프로세스를 스케줄하는것.**
        - CPU 스케줄링에 해당
    - I/O 스케줄링 → 나중에 배움.
- 스케줄러의 성능
    - 프로세스들이 일생 동안 각종 큐에서 대기하는 시간을 얼마나 줄일 수 있을 것이냐 하는 문제

### **처리기 스케줄링의 유형 : 장기 스케줄링**

- 새로운 프로세스의 시스템 진입 허용 여부를 결정
- 멀티 프로그래밍의 정도를 결정함
- Ready Queue에 새로운 프로세스를 넣을지 말지 결정한다.

### **처리기 스케줄링의 유형 : 중기 스케줄링**

- 스와핑 기능의 일부
    - 스왑 공간으로 쫓겨나간 프로세스 전체 또는 일부 중 어느 것을 다시 메인메모리로 스왑인 할 것인지

### **처리기 스케줄링의 유형 : 단기 스케줄링**

- Ready Queue에서 다음에 실행될 프로세스는 누구냐!
- 디스패쳐 라고도 함
    - 장기/중기 스케줄러보다 매우 자주 실행
    - 세밀한 기준으로 다음 번에 실행시킬 프로세스를 선정
- 단기 스케줄러 실행 시점
    - 클럭 인터럽트 - 타이머 시간 할당량 만료시
    - 입출력 인터럽트
    - 운영체제 시스템 호출

### State로 알아보는 스케줄링

![스크린샷 2022-05-25 22.38.56.png](9%20Uniprocessor%20Scheduling%20(1)%2052b0868340f040e2b43dbb8295e2452a/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-05-25_22.38.56.png)

- Ready-Suspend / Blocked-Suspend : 보조기억장치에 있음.
- Ready → Running : Short-term Scheduling

---

### 스케줄링의 단계 도식화

![스크린샷 2022-05-25 22.43.44.png](9%20Uniprocessor%20Scheduling%20(1)%2052b0868340f040e2b43dbb8295e2452a/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-05-25_22.43.44.png)

- **Short-Term Scheduling** → Blocked, Ready, Running

---

### Queue로 알아보는 스케줄링

![스크린샷 2022-05-25 22.46.29.png](9%20Uniprocessor%20Scheduling%20(1)%2052b0868340f040e2b43dbb8295e2452a/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-05-25_22.46.29.png)

---

### Long-Term 스케줄러

- 멀티프로그래밍의 정도를 Control한다.
- 프로세서의 idle한 시간이 일정 threshold(임계치)를 초과하면 Long-Term 스케줄러가 새로운 프로세스를 시스템에 추가시킨다!!!
- 많은 프로세스가 들어가면 메인메모리에 프로세스는 많지만 페이지(프레임)가 상당히 작아지기 때문에 또 페이지폴트가 존나게 일어난다~~

- Long-Term 스케줄러의 결정요소
    1. 언제 새로운 프로세스를 넣을거냐!!!
    2. 어떤 프로세스를 넣을거냐!! 
        - FCFS(First Come First Service)
        - Priority, 실행시간에따라, I/O 요구에 따라…………

### Mid-Term 스케줄러

- 스와핑 기능의 일부.
- 어떤 메모리를 메인메모리에 쳐 넣을것인지… 결국은 멀티프로그래밍의 정도를 결정하는거임.
- Swap out(멀티프로그래밍의 정도를 낮춘다.)
    1. 오랫동안 사용 안한 Process
    2. Priority가 낮은 Process
    3. 페이지폴트가 많이 일어나는 Process
    4. Mem을 존나 많이 사용하는 Process
- Swap in 은 뭐 멀티프로그래밍의 정도를 높인다…

### Short-Term 스케줄러

- Ready Queue에서 다음에 실행될 프로세스는 누구냐!
- **디스패쳐** 라고도 함
    - 장기/중기 스케줄러보다 매우 자주 실행
    - 세밀한 기준으로 다음 번에 실행시킬 프로세스를 선점(preempt)
- 단기 스케줄러 실행 시점
    - 현재 실행중인 프로세스가 Block될 수 있는 Event가 실행 됐을때!!
        - 클럭 인터럽트 - 타이머 시간 할당량 만료시
        - 입출력 인터럽트
        - 운영체제 시스템 호출(System Call)
        - Signals(semaphore…)

---

## **스케줄링 알고리즘 : 단기 스케줄링 평가 기준**

- 사용자 중심 관점(User Oriented) vs 시스템 중심 관점(System Oriented)
    - 사용자 중심 관점 : 응답시간(Response Time)
        - 개별 사용자 or 개별 프로세스의 입장에서 요구한 작업 요청에 대한 Response Time(응답시간)이 얼마나 빠른가.
    - 시스템 중심 관점 : 처리량(Throughput)
        - 프로세서를 얼마나 효율적으로 사용하느냐..
        - 처리량(Throughput) : 단위시간 안에 얼마나 많은 프로세스를 완료시킬 수 있냐.
        - 솔직히 Single User System에서는 별로 관심 안가짐. (지만 빠르면 되니까) 대형 시스템에서 관심 있는 관점이다.
- 성능 중심 관점(Performance) vs 성능 외적 관점(Other)
    - 성능 중심 관점 : 대부분 정량적인 척도로 측정 용이함
    - 성능 외적 관점 : 대부분 질적인 척도로 측정이 어려움

- **스케줄링 평가 척도**
    1. User - Performance
        1. Turnaround Time(처리시간) : 프로세스가 시스템으로 진입한 이후부터 종료까지의 시간.
        2. Response Time(응답시간) : 시스템에 프로세스가 요구한 후 응답 받을때까지의 시간
        3. Deadline(기한) : 프로세스가 완료되어야 하는 시점에 기한이 있는것
    2. User - Other
        1. Predictability(예측 가능성) : 질적으로 어떤 좋은 서비스를 제공해줄거야? 이걸 예측..
    3. System - Performance
        1. Throughput(처리량) : 단위 시간안에 얼마나 많은 프로세스를 완료시키느냐
        2. Processor Utilizaiton(이용률) : 얼마나 프로세서를 Busy하게 만드느냐
    4. System - Other
        1. Fairness(공정성) : Starvation(기아)를 얼마나 발생 안시키느냐, 얼마나 공평하게 분배하느냐
        2. Enforcing Priority(우선순위의 부여) : 우선순위에 따라 프로세스를 실행시킴
        3. Balancing Resource : 시스템에서 Resource들이 얼마나 Busy하게 사용하느냐

---

### **스케줄링 알고리즘 : 다양한 스케줄링 정책들**

- **Priority 스케줄링**
    
    ![우선순위 방식의 큐](9%20Uniprocessor%20Scheduling%20(1)%2052b0868340f040e2b43dbb8295e2452a/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-06-05_19.15.38.png)
    
    우선순위 방식의 큐
    
    - RQ0 ~ RQn까지 Ready Queue에 우선순위를 부여하고 스케줄링하는 방법.
    - RQ0(상위 우선순위)부터 상위 우선순위에 프로세스들이 많다면 RQn(제일 우선순위가 낮은)놈에서 Starvation이 일어날 수도 있다.

### 스케쥴링 정책들의 비교

- **Selection Function(선택함수)**
    - 다음번 실행을 위해 Ready 큐에서 대기중인 프로세스 중 선택에 대한 비교 함수
    - 실행 특성
        - w = 대기한 시간
        - e = 수행된 시간
        - s = 프로세스가 시작해서 종료하기까지의 전체 시간 요구량. e를 포함.
- **Decision Mode :Selection Function이 호출되는 시점**
    - Nonpreemptive(비선점모드) : 프로세스가 Running State가 되면 종료되거나 
    스스로 Block되는(I/O같은 걸로) 것이 아니면 계속 수행되는 것.
    - Preemptive(선점모드) : 현재 실행중인 프로세스라도 OS에 의해 인터럽트가 걸려 비자발적으로 레디큐로 이동된다.
        - 프로세스가 선점될 때
            1. 새로운 프로세스가 진입하는 순간
            2. 인터럽트가 걸려 블록된 프로세스가 Ready State로 들어올 때
            3. Clock Interrupt에 의해 주기적으로 스케줄러가 호출되는 시점.
        - Nonpreemptive보다 Overhead가 많이 발생하긴 하지만 독점하는 걸 막을 수 잇음.
    

![다양한 스케쥴링 정책들의 특징](9%20Uniprocessor%20Scheduling%20(1)%2052b0868340f040e2b43dbb8295e2452a/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-06-05_19.28.52.png)

다양한 스케쥴링 정책들의 특징

### **평균반환 시간 (average turnaround time)**

- 각 프로세스의 (종료시간 - 도착시간) 평균값

### Turnaround Time & Service Time & Normalized Turnaround Time

1. $T_r$: Turnaround Time : Finish Time - Arrival Time
    
    = 프로세스 시작 ~ 끝 = 실행 시간 + 대기 시간
    
2. $T_s$: Service Time : Finish Time - Start Time
    
    = 프로세서에서 진짜 실행되는 시간
    
3. $\frac{T_r}{T_s}$ : Normalized Turnaround Time  

---

### **First-Come-First-Served (FCFS)**

- FIFO(First-In-First-Out) 라고도 함
- 비선점(Nonpreemptive) 모드로 동작 → 자발적으로 종료할때까지 계속 실행함.
- 프로세스는 준비 상태가 되면 준비 큐에 들어감
- 현재 실행 중인 프로세스가 실행을 종료하면 준비 큐에서 대기 중 이던 프로세스 중 가장 오랫동안 기다렸던 프로세스가 다음 번 실행 프로세스로 선택
- FCFS는 (Ts)짧은 프로세스보다는 (Ts)긴 프로세스에게 유리
- 입출력 중심의 프로세스보다 프로세서 중심 프로세스를 우대하는 경향(문제점)
    - I/O는 조금 수행하다가 큐 맨뒤로 가고, 또 맨뒤로 가고 이렇게 반복하는데 프로세서 중심 프로세스는 앞쪽에서 비선점모드로 동작해서 혼자 쭉 수행하고 I/O는 손해를 계속 본다.
    
    ![스크린샷 2022-05-26 01.02.41.png](9%20Uniprocessor%20Scheduling%20(1)%2052b0868340f040e2b43dbb8295e2452a/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-05-26_01.02.41.png)
    
    - Normalized Turnaround Time  크면 기다리는 시간이 많다. → Y에게 정말 불리한 스케쥴링
        - why?
            
            Y는 1t 만큼 실행하려고 99t 를 기다렸다…!
            
    
    ⇒ 실행 시간 (Service time)이 긴 프로세스에게 유리한 스케쥴링이다.
    

---

### **라운드-로빈(Round-Robin)**

- FCFS에서 짧은 프로세스가 피해보는 현상 완화
- 시간을 측정하고 있다가 어떤 긴 프로세스가 일정 시간 이상을 넘어가는 순간 실행을 강제로 중단시키는(preemption) 것 → **Clock Interrupt**
- Preemption(선점)방식으로 동작!
- 라운드-로빈 스케줄링 기법 동작 방식
    - 클럭 인터럽트가 발생하면 클럭 인터럽트 서비스 루틴이 실행
    - 클럭 인터럽트 서비스 루틴은 현재 실행 중이던 프로세스를 준비 큐로 이동
    - 준비 큐에서 FCFS 방식으로 다음 번 프로세스를 골라 실행(제일 오래기다린놈!!)
- 시간 할당량(time slicing, 또는 time quantum) 기법이라고도 함
- 시간할당량의 크기(q)가 라운드-로빈 성능에 미치는 영향
    - 시간할당량이 너무 작으면 → 프로세스 문맥교환(Context Change) 오버헤드가 증가
    - 시간할당량이 너무 크면 → FCFS와 비슷해짐
- 시간할당량의 권장 길이(Time Quantum정하기)
    - 프로세스가 사용자와 최소한 한 번 대화(interaction)하기에 충분하거나(조금 더 크거나)
    - 프로세스 내의 어떤 한 함수 정도는 실행을 마칠 수 있는 충분한 길이
    - 만약 너무 작아버리면 한번 대화(interaction)도 나눠서 해버려야하니까 너무 비효율적이야~
    - 또 너무 커버리면 그냥 FCFS마냥 동작해서 안돼~
- 단점 : FCFS방식으로 스케줄링 되긴 하니까 IO 중심 프로세스보다 프로세서 중심 프로세스를 우대 할 수 밖에 없는 현상
    - IO는 잠깐의 시간동안 활성되고 레디큐로 가게 된다.. (IO는 느리잖아요.~)
    - 입출력 중심 프로세스는 존나 사용안하고 프로세서중심은 계속 사용하니까 프로세스 간 응답시간의 편차도 겁나 커진다.
- 시분할 시스템, 트랜잭션 시스템에 효과적으로 사용된다. (은행, DB, …)

### 가상 라운드-로빈(Virtual Round-Robin)

![스크린샷 2022-06-05 20.05.57.png](9%20Uniprocessor%20Scheduling%20(1)%2052b0868340f040e2b43dbb8295e2452a/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-06-05_20.05.57.png)

- I/O 중심 프로세스를 위한 새로 고안한 방법
- FCFS Auxiliary(보조) Queue를 추가 도입했다.
- I/O가 끝난 놈은 원래 Ready큐 맨뒤로 갔지만 I/O가 끝난놈은 Auxiliary(보조)큐로 간다.
- 보조큐 > 메인레디큐 → 우선순위가 보조큐가 더 높다!
- 보조큐에 있던 놈이 먼저 선택 돼서 간다.
- 저번 실행 때 Time Quantum에서 다 못채운 시간만큼만 실행하게 해서 역차별을 안당하게 한다!
- (Basic Time Quantum) - (Last Select때 쓴 running 시간.)

---

### **Shortest-Process-Next (SPN)**

- **비선점(Nonpreemptive) 모드**로 동작
- FCFS의 긴 프로세스 우대 편향성 완화 방법
- 가장 서비스 시간(Ts)이 짧은 프로세스를 먼저 실행시키는 정책
- 종료 시까지 남아 있는 실행시간이 가장 짧은 프로세스를 다음 번 프로세스로 선택
- 실행 시간이 짧은 프로세스가 (비록 늦게 도착했더라도) 긴 프로세스들보다 먼저 스케줄링
- **SPN 구현 상의 문제점**
    - 각 프로세스가 요구하는 총 실행 시간(Processing Time)을 미리 알아야 함
    - 미리 알기가 어렵기 때문에 시스템은 이를 실행시간(프로세싱타임)을 유추할 수 있어야 함
        1. 프로그래머가 알려주는 방법
        2. 몇번 측정을 거친 뒤 유추하는 방법.
- SPN의 장점
    - FCFS의 긴 프로세스 우대 편향성을 완화 시킬 수 있음.
    - Response Time을 엄청 증가시킬 수 있음.
- SPN의 단점
    1. 짧은 프로세스들이 지속적으로 시스템에 진입한다면 이들 보다 상대적으로 긴 프로세스가 기아(Starvation) 상태에 빠질 수 있음(비선점으로 진행해서 그럼)
    2. 긴 프로세스들은 상대적으로 처리 완료에 대한 예측이 어렵다.
        
        → 시분할, 트랜잭션 시스템에 적합하지 않다.
        

### **Shortest-Remaining-Time (SRT)**

- SPN의 **Preemptive(선점)모드 버전**에 해당
- 예상되는 **남아있는 실행 시간이 가장 짧은** 프로세스가 다음 번 프로세스로 선택
    - SPN은 그냥 짧은 프로세스를 선택했음
- "새로 도착한 프로세스의 예상되는 남아있는 실행 시간(=서비스시간)" < "현재 실행 중인 프로세스의 예상 실행 시간" 이면 늦게 도착했더라도 현재 실행 중인 프로세스를 중단하고 곧장 선택
- 장점
    - FCFS의 긴 프로세스 우대 편향성 완화
    - Turnaround Time 측면에서 엄청난 성능. 기존에 존재하던 남아있는 시간이 긴 놈보다 새로 도착한 남아있는 시간이 짧은 놈에게 우선순위를 주기 때문이다.
- 단점
    - Service Time을 계속 기록해야함.
    - 매 스케줄링 때마다 프로세스들의 남아있는 실행 시간을 평가해야 하는 부담 → 오버헤드
    - 긴 프로세스가 기아 상태에 빠질 가능성

---

### **Highest-Response-Ratio-Next (HRRN)**

- 준비 큐에 있는 프로세스 중 R값(응답 비율)이 가장 큰 프로세스를 다음 번 프로세스로 선택
    - 프로세스가 시스템 내에 머문 시간(즉, 프로세스의 나이)을 고려
    - 서비스 시간이 짧은 프로세스의 R값이 상대적으로 크기 때문에 짧은 프로세스를 우대하는 편.
        - 분모에 expected service time이기 때문에 서비스 시간이 짧으면 분모가 작아짐 → R값이 커짐.
    - 대기 시간(w) 때문에 시스템에 오래 머문 긴 프로세스도 오래 머물면 머물수록 R 값이 커지기 때문에 홀대 받지는 않음
        - 분자에 waiting한 시간이 있기 때문에 Ratio값이 커진다.
- 응답 비율의 정의
    
    ![스크린샷 2022-05-26 03.04.24.png](9%20Uniprocessor%20Scheduling%20(1)%2052b0868340f040e2b43dbb8295e2452a/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-05-26_03.04.24.png)
    

R = 응답 비율

w = 처리기를 기다리며 대기한 시간

s = 예상되는 서비스 시간

---

### **피드백 (Feedback) 스케줄링**

- 프로세스들의 예상되는 서비스 시간을 미리 알아낼 필요가 없음(SPN,SRT,HRRN)
- 오랫동안 실행하고 있는 프로세스들이 단계적으로 불이익(Penalty)를 받도록 하는 방법.
- 결국 남아있는 실행시간이 아닌 지금까지 실행한 시간에 관심을 두는 것.
- 중단점을 만날 때마다 프로세스는 한 단계 낮은 우선 순위의 준비 큐로 강등되어 진입
- 새로 도착한 프로세스일수록, 그리고 짧은 프로세스 일수록 오래된 프로세스나 긴 프로세스보다 우대 받는 정책
    - 새로 도착한 프로세스 : Ready Queue 0 로 간다.
    - 실행되다가 선점점(CPU를 빼앗기는 시점)에 도달하면 원래 있었던 곳보다 한단계 낮은 RQ로 간다!
    - 각 큐에서는 FCFS마냥 동작한다.
    - 제일 마지막 Priority지점에서는 빠져나간 다음 다시 같은 큐의 맨 뒤로 들어가 RR 방식으로 동작한다.

![스크린샷 2022-05-26 15.02.49.png](9%20Uniprocessor%20Scheduling%20(1)%2052b0868340f040e2b43dbb8295e2452a/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-05-26_15.02.49.png)

- Starvation 처리
    
    처리시간이 긴 프로세스는 하위 레벨 RQ로 이동하게 된다.
    
    만약 어느정도 시간이 지났다면 상위 레벨 RQ로 올려주어서 기아상태를 예방한다.
    

### 스케쥴링 정책 비교

![프로세스 표](9%20Uniprocessor%20Scheduling%20(1)%2052b0868340f040e2b43dbb8295e2452a/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-06-05_20.20.57.png)

프로세스 표

![스케쥴링 수행 과정 비교](9%20Uniprocessor%20Scheduling%20(1)%2052b0868340f040e2b43dbb8295e2452a/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-06-05_20.20.17.png)

스케쥴링 수행 과정 비교

![Normalized turnaround time을 이용한 프로세스별 효율 비교](9%20Uniprocessor%20Scheduling%20(1)%2052b0868340f040e2b43dbb8295e2452a/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-06-05_20.25.56.png)

Normalized turnaround time을 이용한 프로세스별 효율 비교

위의 예시에서는 SRT가 프로세스별 효율이 평균적으로 괜찮은 모습을 보여주고 있다.

---

### Fair-Share 스케줄링

- 프로세스 집합 단위의 스케줄링 방식
- 프로세스의 집합 or User의 그룹을 기반으로 스케줄링을 진행.
- "공정함을 나누어 갖는다."라는 의미가 함축되어 있음.
- Fair Share 스케줄러(**FSS**)
    - 프로세스 집합의 실행 기록들을 고려해서 선택.
    - Priority 고려
        1. 프로세스의 Priority
        2. 최근에 프로세스가 프로세서를 사용한 양
        3. 최근에 그룹에서 프로세서를 사용한 양
    
- Process j, Group k , Interval i
    - CPUj(i) : 프로세스 j가 Interval i동안 프로세서를 사용한 양.
    - GCPUk(i) : 그룹 k에서 i동안 프로세서를 사용한 양.
    - Pj(i) : 프로세스 j의 우선순위(낮은 값일 수록 Priority가 높은거임)
    - Basej : 프로세스 j의 기본 우선순위
    - Wk : 그룹 k에 할당된 가중치. W1부터 Wk까지 더하면 1임.
    
    ![스크린샷 2022-05-26 15.26.33.png](9%20Uniprocessor%20Scheduling%20(1)%2052b0868340f040e2b43dbb8295e2452a/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-05-26_15.26.33.png)
    
    - 이전 Interval에서 프로세서 사용량으로 현재 Interval에서 사용한 값을 구한다.
    - Fair-Share 스케줄러(FSS)의 동작 예시.
        
        ![스크린샷 2022-05-26 15.34.51.png](9%20Uniprocessor%20Scheduling%20(1)%2052b0868340f040e2b43dbb8295e2452a/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-05-26_15.34.51.png)
        
- Fair-Share 스케줄러(FSS)의 동작 예
- 세 개의 프로세스가 두 개의 그룹을 구성
- 각 그룹의 가중치는 0.5
- 스케줄링 순서 : A, B, A, C, A, B, …
- 그룹 0 → 그룹 1 → 그룹 0 → … 이런 식으로 번갈아가면서 실행된다.

---

### Unix에서의 스케줄링

- 시분할 대화형 환경에서 사용됨. → 유저에게 좋은 Response Time을 제공하기 위해 고려됨.
- 우선순위가 낮은 Background Job도 기아상태에 안빠지도록 스케줄링을 고려함
- multilevel feeedback + 라운드로빈(각 우선순위 큐)스케줄링
- 매 초마다 선점을 수행
    - 이때 우선순위는 프로세스의 타입, 실행 기록을 고려해서 우선순위를 정한다.

![스크린샷 2022-05-26 15.51.37.png](9%20Uniprocessor%20Scheduling%20(1)%2052b0868340f040e2b43dbb8295e2452a/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-05-26_15.51.37.png)

- 나머지는 Fair Share와 똑같음 그치만 Group을 고려하지 않는다!
- nicej : 사용자가 지정할 수 있는 값. 값을 올릴 수록 Priority가 올라간다.

### Band

- Base Priority를 구분해 놓은 것.
    
    → 어느 큐에 들어갈 것인지?
    
- block device의 접근을 최적화시키기 위해서 사용한다.
- Swap이 제일 높고 User Process가 제일 낮다.
- I/O 기반 프로세스는 CPU 자주 할당받긴 하지만 자꾸 놓쳐서 높게 잡아놨음

음 그렇다면 사용자 프로세스가 너무 늦게 받는 것이 아닌가?

NO! IO 관련 작업은 실행 시간이 적기 때문에 바로 블락되어서 사용자 프로세스도 충분한 실행 기회를 얻을 수 있다.

![스크린샷 2022-05-26 15.54.00.png](9%20Uniprocessor%20Scheduling%20(1)%2052b0868340f040e2b43dbb8295e2452a/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-05-26_15.54.00.png)

- UNIX 프로세스 스케쥴링 예시
    
    ![스크린샷 2022-06-05 21.27.20.png](9%20Uniprocessor%20Scheduling%20(1)%2052b0868340f040e2b43dbb8295e2452a/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-06-05_21.27.20.png)