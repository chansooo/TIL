# VM - Software

# 8-2 운영체제 소프트웨어

### OS의 메모리 관리 설계는 세가지 기본선택영역에 의존한다.

1. VM를 사용할 것인지
2. 페이징 or 세그먼트 or 둘다
3. 페이징을 통해 효과적으로 메모리 관리를 하는 알고리즘을 선택
    
    (세그먼트만 사용하는 OS는 거의 없고, 페이징을 사용해야 함)
    

## 페이징 알고리즘

---

- Key 이슈 : PFR(Page Fault Rate)를 최소화 → SW 오버헤드를 줄여야 한다.
    - 페이지들을 교체할 때 어떤 것을 선택해서 PFR을 줄일까?
    - 페이지의 I/O 작업 시 PFR을 줄이는 방법은?
    - 프로세스 스위칭을 통해 PFR을 줄이는 방법은?

### VM을 위한 운영체제 전략들.

- **Fetch(반입) 정책**
    - Demand paging
    - Prepaging
- **Placement(배치) 정책**
- **Replacement(교체) 정책**
    - Basic algorithm
        - Optimal
        - Least recently used (LRU)
        - FIFO
        - Clock
    - Page Buffering
- **Resident Set Management (상주 집합 관리)**
    - Resident set size (상주 집합 크기)
        - Fixed (고정)
        - Variable (가변)
    - Replacement Scope (범위가 변경될 때)
        - Global (전역)
        - Local (지역)
- **Cleaning 정책**
    - Demand
    - Precleaning
- **Load Control (부하 제어)**
    - Degree of multiprogramming

### 1. Fetch Policy (반입 정책)

: 언제 페이지를 메모리로 불러올 것인지

: 각 페이지를 언제 메인메모리로 불러올것인지 결정

1. **Demand Paging (요구된 페이지)**
    
    : 요구된 페이지만 불러온다.
    
    - 페이지가 메인메모리로 반입되는 시점은 해당 페이지의 일부가 참조될 때.
    - 프로세스가 처음 시작될 때 페이지 폴트가 많이 발생
    - 지역성 원칙에 따라서 시간이 지나면 페이지들이 메인메모리에 많이 올라와 있을 것이고 더 이상 페이지 폴트가 많이 발생하지 않는다.
        
        But, 로컬이 옮겨가면 다시 페이지 폴트가 많이 발생할 것이다. → 로컬이 옮겨간다...?
        
2. **Prepaging(선페이징)-보조기억장치의 특성을 이용.**
    
    : 페이지 폴트 시에 요구된 페이지뿐만 아니라 다른 페이지들도 같이 반입한다.
    
    - 보조기억장치는 seek time(탐색시간)이 발생하기 때문에 연속적으로 저장된 페이지를 한 번에 불러온다
        
        → 더 효율적이다.
        
    - But, 불러왔는데 참조되지 않는다면 불필요한 작업이다. → 비효율
        
        ⇒ 따라서 프로세스가 처음 시작되거나, 로컬이 옮겨가서(페이지폴트가 발생해서) 지역성이 떨어졌을 때 사용한다.
        

### 2. Placement Policy (배치 정책)

: 프로세스의 일부(Piece)를 실제 메모리(메인메모리) 위치 중 어디에 배치할 것인가?

- 세그먼트 시스템 : 중요한 설계 이슈가 된다.
    
    세그먼트는 가변길이.
    
    (이전 챕터 세그먼트 부분에서 first-fit, next-fit 같은 배치 정책)
    
- 페이징 시스템 or 혼합 시스템 :  고려할 필요가 없다.
    
    페이지 크기와 프레임 크기가 같기 때문에 아무 곳이나 배치해도 문제가 없다!
    
- **NUMA(Non Uniform Memory Access) 멀티프로세서**
    
    : 프로세서와 메모리 모듈 간 거리를 이용해서 가까운 메모리에 할당 → 성능 최적화
    

### 3. Replacement Policy (교체 정책)

: 새로운 페이지가 반입되기 위해서 기존에 메인메모리에 있던 교체할 페이지를 선택해야 한다.

- 가까운 미래에 사용되지 않을 페이지를 선택해서 교체해야 성능이 높아진다.
- Trashing(쓰레싱)이 발생하면 CPU 사용보다 I/O 작업으로 인한 부하가 더 많아지므로 좋은 예측이 필요하다.

- 과거의 동향을 파악해서 최대한 좋은 선택을 하고자 한다.
    
    → 이 과정에서도 하드웨어 및 소프트웨어 오버헤드가 발생하므로 너무 복잡한 예측은 오히려 좋지 않다.
    

### Frame Locking

교체 알고리즘을 보기 전에 제약조건 중 하나인 프레임 잠금 개념을 알아보자.

: OS는 일부 페이지 프레임을 잠가 둘 수 잇는데, 만약 잠게되면 해당 프레임에 적재된 페이지가 교체되지 않도록 한다.

- 프레임마다 lock bit를 이용한다.
- 커널의 대부분의 프레임은 lock된 상태로 작동한다.
- I/O 버퍼, time-critical area는 실시간 반응을 해야하므로 lock시킨다.

### 교체 정책의 Basic 알고리즘

- **Optimal(최적): 미래**
    
    : 미래에 참조될 페이지들을 미리 알고 있을 때 → 최적의 결과이다.
    
    미래에 어떤 페이지가 참조가 제일 안될까를 다 알고있어서 그 놈을 선택한다.
    
    하지만 실제로는 불가능하고, 다른 알고리즘과 비교할 때 사용한다.
    
- **LRU (Least Recently Used): 과거**
    
    : 과거에 가장 오랫동안 참조되지 않은 페이지를 선택 (지역성의 원칙을 이용)
    
    지역성의 원칙에 따르면 가장 오랫동안 참조되지 않은 페이지면 현재도 이 지역을 이용하고 있지 않다는 가능성이 젤 높음.
    
    - 장점 : optimal에 가까운 성능을 보인다.
    - 단점 : 각 페이지가 마지막으로 참조된 시간을 저장해야 한다 → 오버헤드 발생
        
               :  그리고 구현하기 어렵당.
        
               : 스택을 사용해도 비용이 상당히 크다.
        
- **FIFO (First-in-First-out)**
    
    : 메모리에 가장 오래 있었던 페이지를 선택
    
    - 장점 : 순환 버퍼를 이용해서 매우 간단하게 구현이 가능하며, 관리가 쉽다.
    - 단점 : 오래 남아 있었더라도 계속 사용되는 페이지가 선택되는 경우 → 계속 in/out 하게 된다
- **Clock**
    
    : 각 프레임마다 `use` bit를 가진다.
    
    <aside>
    📄 페이지가 메모리에 처음 적재되었을 때 → `use = 1` 로 setting한다.(initialize)
    
    해당 페이지가 참조 될때마다 `use`는 1로 설정됨.
    
    **교체할 페이지를 찾을 때 OS는 순서대로 점검하며 `use=0` 인 프레임을 찾는다.**
    
    OS가 use가 1인 프레임을 만났을 때 → `use = 0` 으로 down 시킴.
    
    OS가 use가 0인 프레임을 만났을 때 → 교체 선택 
    
    </aside>
    
    - 순환 버퍼(Circular Buffer)를 이용해서 구현, **Clock policy**라고 한다.
    - FIFO와 유사하지만, 계속 사용되는 페이지는 `use bit = 1` 을 이용해서 보호한다.
    
    ![스크린샷 2022-05-16 16.40.19.png](VM%20-%20Software%203144913671994c2e8e979ac4f0332a88/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-05-16_16.40.19.png)
    

- 각 알고리즘의 비교 예시
    
    ![스크린샷 2022-05-16 16.27.45.png](VM%20-%20Software%203144913671994c2e8e979ac4f0332a88/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-05-16_16.27.45.png)
    
    성능 : OPT > LRU > CLOCK > FIFO
    
    OPT : 구현 불가
    
    LRU : 구현 어려움, 오버헤드 증가
    
    but, 실제 OS에서 사용한다.
    
    FIFO : 낮은 성능
    
    CLOCK : 구현도 쉽고, 성능도 준수 → 적절
    

### 교체 정책 알고리즘 분석

![스크린샷 2022-05-16 16.44.58.png](VM%20-%20Software%203144913671994c2e8e979ac4f0332a88/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-05-16_16.44.58.png)

CLOCK : 오버헤드를 고려했을 때 적절한 선택이 될 수 있다.

LRU : 최적의 성능을 위해서 사용할 수 있다. (오버헤드를 더 고려하더라도)