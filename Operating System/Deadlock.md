# Deadlock

# 병행성 : 교착상태와 기아상태

## 1. 교착상태 정의(Deadlock)

- 상호 배제에 의해 나타나는 문제점으로, 둘 이상의 프로세스들이 자원을 점유한 상태에서 서로 다른 프로세스가 점유하고 있는 자원을 요구하며 무한정 기다리는 현상을 의미한다.
- 2개 이상의 프로세스들이 공유 자원에 대한 경쟁(compete)이나 통신(communicate) 중에 발생한다.
- block 상태에 놓여 필요한 자원을 이용하기 위해 기다릴 때 발생한다.
- Block된 녀석의 Event를 기다리며 Block되어 있는 경우.
- 영구적인(permanent) block 상태
- 제한된 자원의 이용률을 높이고 시스템 효율성을 증가시키기 위해 사용하는 병행 처리 기술과 자원 공유에 따른 부작용이다.

### Example of Deadlock

![IMG_6B41E0CB3C0A-1.jpeg](Deadlock%20fbb1f16c875a4e57bf3f64fce7b4cb5d/IMG_6B41E0CB3C0A-1.jpeg)

- 1, 6 : 1은 Process Q가 쭉 실행되고 난 뒤 P가 실행된다는 것 → Deadlock 절대 안생김
- 2 : Process Q가 자원 A,B를 먼저 점유하고 P가 실행됨. P는 A,B를 점유하려고 하지만 이미 Q가 점유하고 있기 때문에 Block되고 Release되는걸 기다린다. 그리고 Release되면 P가 쭉 실행된다.
- 3 : Q는 B를, P는 A를 점유 → Q는 다음으로 A를 요구, P는 다음으로 B를 요구 → Deadlock!!

### Example of No Deadlock

![IMG_3F405BD644A1-1.jpeg](Deadlock%20fbb1f16c875a4e57bf3f64fce7b4cb5d/IMG_3F405BD644A1-1.jpeg)

- Deadlock을 피하기 위해 Process P의 순서를 바꿨다.
- P : Get A → Release A → Get B → Release B
- 3번 : Q가 B를 점유 → P가 A를 점유 → Q가 A를 요청 → Q Block → P가 A를 Release →  Q 가 A를 점유 ,,,

### 교착상태에 빠지는 Resource의 종류

1. Reusable Resource(재사용 가능한 자원)
    - 한번에 단 하나의 Process만 사용하게끔 해야되고
    - 이 자원은 고갈되지 않음.
    - Ex) 프로세서, I/O channel, 메인메모리, Device, Data Structure(파일, database, 세마포어..)
2. Consumable Resource(소모성 자원)
    - 한개가 생성(create, produce)되고 소비(destroy, consume)되는 자원.
    - Ex) Interrupt, Signal, Message, Information
    - Ex) I/O buffers

### Deadlock Example 1 → 재사용 가능한 자원을 서로 요구.

![IMG_F61AD2AD3EA3-1.jpeg](Deadlock%20fbb1f16c875a4e57bf3f64fce7b4cb5d/IMG_F61AD2AD3EA3-1.jpeg)

### Deadlock Example 2 → Memory 요구.(재사용가능한 자원)

- 200KB를 쓸수있다.
- P1이 첫번째 요청으로 80KB, P2가 첫번째 요청으로 70KB를 요청 (남은 사용가능 메모리 50KB)
- P1이 두번째 요청으로 60KB를 요청 → Blocked
- P2가 두번째 요청으로 80KB를 요청 → Blocked.
- 두 Process가 Block → 요청될 메모리의 양을 미리 모른다면 교착상태를 해결하기 어려움. → 나중에 가상메모리로 해결한다!

### Dedlock Example3 → Consumable Resource(메세지 주고받기...)

- 두개의 프로세스가 메세지를 서로 받은 다음 메시지를 보내주겠다 라고 코드를 짜면 Deadlock이 걸림.
- 코딩을 하면서 예방하기 솔직히 어렵다. 찾아내기 힘들다... 말을 너무 못하신다...

## 2. 교착상태가 발생하기 위한 필요충분조건

### 자원 할당 그래프(Resource Allocation Graph)

![Resource Allocation Graph.](https://images.velog.io/images/pu1etproof/post/649c2df4-1c6d-4fdf-b08b-ad378a56b613/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202021-08-20%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%201.26.27.png)

Resource Allocation Graph.

- 자원 안의 점 → 동시에 접근 할 수 있는 Process의 개수.

### Deadlock이 발생하기 위한 필요충분조건  → 암기!!!!

1. 상호배제 조건(mutual exclusion) : 한 순간에 한 프로세스만이 자원을 사용할 수 있어야 한다.
2. 점유대기 조건(hold and wait) : 이미 자원을 보유한 프로세스가 다른 자원을 요청하며 기다려야 한다.
3. 비선점 조건(no preemption) : 프로세스에 의해 점유된 자원을 다른 프로세스가 강제로 빼앗을 수 없다.
4. 환형 대기 조건(circular wait) : 프로세스들 간에 닫힌 연결이 존재한다. 자원 할당 그래프에서 환형이 만들어지는 것이다.

→ 1,2,3을 만족한다고 Deadlock이 걸리는게 아님.

1,2,3을 만족하고 Circular Wait가 발생하면 Deadlock 상태로 들어간다.

1,2,3 → 필요조건.

4 → 충분조건

### Deadlock Approaches - 3가지.

1. Deadlock Prevention - 필요충분조건 4가지 중 하나를 못하게 하는것.
아예 예방을 하는거임.
2. Deadlock Avoidence - 
자원할당을 하다가 이번 할당에 deadlock 걸릴거같아! → 할당 X
필요충분조건 모두 허용..
할당은 하되, 할당하기 전에 Check해주는 기법.
3. Deadlock Detection -
자원을 무조건 할당. But 주기적으로 계속 확인해준다.
그리고 deadlock이 걸렸으면 복구시킬 수 있는 기법을 적용해서 검출, 해결.

## 3. 교착상태 예방(Deadlock Prevention)

교착상태가 일어나는 상호배제, 점유대기, 비선점 조건들을 허용하지 않거나 직접적으로 환형대기가 생기지 않도록 하는 것이다. 필요조건 3가지 중 하나를 못하게 하는 것. or 충분조건인 Circular Wait을 못하게 하는것. 

> 간단 정리
> 
> - 상호 배제 : 운영체제에서 반드시 보장해주어야 함
> - 점유 대기 : 프로세스가 필요한 모든 자원을 한꺼번에 요청
> - 비선점 : 프로세스가 새로운 자원 요청에 실패하면 기존의 자원들을 반납한 후 다시 요청 or 운영체제가 강제적으로 자원을 반납시킴
> - 환형 대기 : 자원 할당 순서(자원 유형)를 미리 정해두면 없앨 수 있음

### 교착상태 예방(Prevention) 전략 두가지.

1. 간접적(Indirect) - 필요 조건(세가지) 중 하나를 Prevent하는 것.(허용 X) 
2. 직접적(Direct) - 충분 조건인 Circular Wait가 발생하지 않도록 하는것.

### 1)  상호 배제 - Prevention 불가!!

- 시스템을 설계할 때 상호 배제 조건(Mutual Exclusion)을 없앨 수는 없으므로 운영체제가 이를 반드시 지원해주어야 한다. 따라서 상호 배제는 Prevention 할 수 없다.

### 2) 점유 대기 - 간접적인 방법으로 Prevention 가능!!

- 프로세스는 자신이 사용할 모든 자원을 한번에 요청하는데, 만일 모든 자원을 할당받을 수 있으면 계속 수행된다. 반면 하나의 자원이라도 할당 받지 못하면, 어떠한 자원도 할당받지 않은 채 대기(Block)하도록 하는 것이다.
- 이 방법을 사용하면 점유 대기는 없앨 수는 있으나 세 가지 문제점(비효율성)이 생긴다.
    1. 프로세스가 자원을 할당 받을 때까지 계속 기다려야한다는 것(Starvation가능..)
    2. 한꺼번에 받은 자원 중 일부는 잠깐만 사용하고 안쓰는데 계속 자원을 들고있으면 자원이 효율적으로 사용되지 않는다
    3. 메모리가 동적으로 할당될수도 있기 때문에 이 프로세스가 얼마나 하드디스크를 사용할지 등등 알 수가 없음. 프로세스가 미래에 필요로 할 자원을 예측하기 어려움.

즉, 점유대기를 없애기 위해서는 모든 수준(모듈, 프로세서, 스레드 등등)이 요구하는 모든 자원을 미리 알아야 한다.

### 3) 비선점 - 간접적인 방법

비선점 조건은 두 가지의 방법으로 없앨 수 있다. 

1. 자원을 점유한 프로세스가 다른 자원을 요청했을 때 할당받을 수 없다면, 일단 자신의 점유한 자원을 반납하고 이후 프로세스가 원래 자원과 새로 원하는 자원을 함께 요청하는 것, 
2. 한 프로세스에서 다른 프로세스가 점유한 자원을 원하면 운영체제가 우선순위에 따라 다른 프로세스가 점유한 자원을 강제적으로 반납시키고 그것을 원하는 프로세스에 할당할 수 있다.

비선점을 없애는 것은 자원의 상태를 복구하고 저장하기 쉬운 자원에 사용할 수 있다. ex) 프로세서

### 4) 환형대기

환형대기 조건들은 자원들의 할당 순서를 정하면 없앨 수 있다. 예를 들어 프로세스가 자원 R을 할당받았다면, 이후 이 프로세스는 자원 R 다음 순서를 갖는 자원들을 요청할 수 있는 것이다. 즉 자원마다 할당순서를 정해 R1 < R2 인 할당 순서를 정했다고 하면 R1을 할당받으면 그 다음 R2가 할당될 수 있게 된다. 만약 P1, P2 프로세스 중 P1가 R1을 할당하고 R2를 요청했다. 여기서 교착상태가 되려면 P2가 R2를 할당하고 R1을 요청해야하는데 이는 운영체제에서 정한 할당 순서에 위배되기 때문에 나타날 수 있다.

환형 대기를 없애는 일은 프로세스의 수행 지연과 불필요한 자원 할당 거부를 생기게 할 수 있다.

## 4. 교착상태 회피(avoidence)

> 예방과 회피의 차이점 : 교착상태 예방은 미리 교착상태를 생기게 하는 조건을 없애는 것이지만 이는 자원의 사용과 프로세스 수행에 비효율을 만든다.교착상태 회피(Avoidence)는 상호배제, 점유대기, 비선점을 허용하지만 그렇다고 자원 할당 순서를 미리 정하지도 않는다.그 대신, 자원을 할당할 때 교착상태가 발생 가능한 상황으로 진행하지 않도록 고려하는 방법이다.
> 

## 회피 방법

### 1-1) 프로세스 시작 거부(Process Initialization Denial)

프로세스가 시작하려할 때 요구하는 자원 할당이 교착상태 발생의 가능성이 있으면, 프로세스를 시작시키지 않는 것이다.

### 2) 자원 할당 거부(Resource Allocation Denial)

수행 중인 프로세스가 요구하는 추가적인 자원 할당이 교착상태 발생의 가능성이 있으면, 자원을 할당하지 않는 것이다.

- 자원을 할당할 때 교착상태가 발생할 가능성이 있는지 여부를 동적으로 판단
- 교착상태의 가능성이 없을 때 자원을 할당한다.즉, 안전한 상태를 계속 유지할 수 있을 때에만 자원을 할당한다.

### 자원할당을 거부하는 방법 : 은행원 알고리즘

> 은행원 알고리즘에서의 시스템 상태 구분
> 
> - 안전 상태(safe state): 교착상태가 발생하지 않도록 프로세스들에게 자원을 할당할 수 있는 할당 경로(진행 경로)가 존재
> - 불안전 상태(unsafe state) : 할당 경로(진행 경로)가 없음

![https://images.velog.io/images/pu1etproof/post/d1c41c32-a92a-41aa-8601-d2bda9543a8a/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202021-08-23%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%204.23.44.png](https://images.velog.io/images/pu1etproof/post/d1c41c32-a92a-41aa-8601-d2bda9543a8a/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202021-08-23%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%204.23.44.png)

먼저 (a) 상태를 보자.프로세서 1~4가 각각 R1~3에 대한 자원 요구를 “요구 행렬 C”에서 볼 수 있다. 그리고 현재 P1~4 가 각각 할당받은 자원을 “할당 행렬A”에서 볼 수 있고, 아직 할당 받지 못해서 필요한 자원을 “C-A”에서 볼 수 있다.R1~3에 대한 총 자원은 R표에서 볼 수 있다. 그리고 R1~3에서 사용가능한 벡터가 V표에 나와있다.

그럼 여기서 과연 이 상태가 안전한지 불안전한지 살펴보면,먼저 A상태에서 가용 가능한 자원으로 끝낼 수 있는 프로세서는 P2 이므로, P2에게 부족한 R3 자원을 1 주면 P2는 끝나고 자신이 가진 자원을 반납하고 B 상태로 넘어간다.B에서는 P1을 완료하여 P1을 끝내고 C상태로 넘어간다.C에서는 P3을 끝낼 수 있으므로 P3을 끝내고 D상태로 넘어간다. D상태에서 P4를 끝내면 수행이 끝난다. **결론적으로 모든 프로세서를 모두 무사히 끝내게 되므로 안전한 상태이다.**

> 위의 경우에서 불안전 상태로 판별나려면?
> 
> 
> ![https://images.velog.io/images/pu1etproof/post/9aab19d8-7c20-4908-84c6-39587ad80a48/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202021-08-21%20%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB%202.36.43.png](https://images.velog.io/images/pu1etproof/post/9aab19d8-7c20-4908-84c6-39587ad80a48/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202021-08-21%20%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB%202.36.43.png)
> 

### 3) 교착상태 회피의 장단점

### 장점

- 교착상태 예방에 비해서 자원 할당이 훨씬 자유롭기 때문에 시스템에서 자원 효율이 높아진다.

### 단점

- 각 프로세스들이 사용할 최대 자원 요구량을 운영체제에게 미리 알려줘야 한다
- 프로세스들은 서로 독립적으로 수행 순서 같은 종속 관계가 없어야 한다
- 자원 개수가 고정적이여야 한다
- 자원을 선점한 상태로 종료되는 프로세스가 없어야 한다

## 5. 교착상태 발견(deadlock detection)

교착상태 발견은 자원 할당이 요구될 때마다 매번 수행할 수 있고, 주기적으로 가끔씩 수행될 수도 있다.

### 교착상태 발견 알고리즘

![https://images.velog.io/images/pu1etproof/post/2c01fc77-b6e8-4298-8b59-945c6e54a6e3/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202021-08-21%20%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB%202.41.26.png](https://images.velog.io/images/pu1etproof/post/2c01fc77-b6e8-4298-8b59-945c6e54a6e3/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202021-08-21%20%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB%202.41.26.png)

1) 할당 행렬 A에서 행의 값이 모두 0인 프로세스를 우선 표시한다.2) 임시 벡터 W를 만든다. 그리고 현재 사용 가능한 자원의 개수(결국 가용 벡터 V의 값)를 벡터 W의 초기값으로 설정한다.3) 표시되지 않은 프로세스들 중에서 수행 완료 가능한 것이 있으면 (요청 행렬 Q에서 특정 행의 값이 모두 W보다 작은 행에 대응되는 프로세스)이 프로세스를 표시한다. 만일 완료 가능한 프로세스가 없으면 알고리즘을 종료한다.4) 단계 3의 조건을 만족하는 행을 Q에서 찾으면, 할당 행렬 A에서 그 행에 대응되는 값을 임시 벡터 W에 더한다.그리고 3단계를 다시 수행한다.

> 쉽게 설명1. P4는 할당 받은 자원이 없다. 따라서 P4에 마킹을 한다.2. 가용벡터 V는 (0 0 0 0 1)로 초기화 된다.3. P3의 요청을 만족할 수 있으므로 P3에 마킹한다. 가용벡터 V가 (0 0 0 1 1)이 된다.4. 마킹이 되지 않은 프로세스들 중에서 가용벡터로 끝낼 수 있는 프로세스가 존재하지 않으므로 알고리즘이 종료된다.
> 

**알고리즘 종료 후에도 P1과 P2는 마킹되지 않은 상태로 남아 있으며 이는 P1과 P2가 교착상태임을 뜻한다.**

## 6. 교착상태 회복 알고리즘(deadlock recovery)

교착상태가 발견되면 그것을 해결하기 위한 기법이 필요하다.

### 회복 알고리즘 종류

1) 교착상태에 포함된 모든 프로세스들을 종료시키는 것→ 생각보다 많은 운영체제가 사용한다.2) 교착상태에 포함된 각 프로세스의 수행을 일정 체크포인트 시점으로 롤백한 후 다시 수행시키는 것→ 교착상태가 다시 발생할 가능성이 존재한다.하지만 병행처리의 비결정 특성으로 인해 확률이 낮기는 하다.3) 교착상태가 없어질 때까지 교착상태에 포함된 프로세스들을 하나씩 종료시키는 것→ 종료시키는 프로세스는 비용이 가장 적은 것부터 종료된다. 하나씩 종료시키면서 발견 알고리즘을 실행 시킨다.4) 교착상태가 없어질 때까지 교착상태에 포함된 자원을 하나씩 선점시키는 것→ 자원은 비용이 가장 적은 것부터 선택한다.자원을 선점시키고 발견 알고리즘을 통해 교착상태가 사라지면 그 프로세스를 자원을 할당 받기 전으로 되돌린다.5) 종료(또는 선점될) 프로세스 선택 기준

- 지금까지 사용한 프로세서 시간이 적은 프로세스부터
- 지금까지 생산한 출력량이 적은 프로세스부터
- 이후 남은 수행시간이 가장 긴 프로세스부터
- 할당 받은 자원이 가장 적은 프로세스부터
- 우선 순위가 낮은 프로세스부터

## 7. 통합적인 교착상태 전략

- 교착상태 예방, 회피, 발견
    
    ![https://images.velog.io/images/pu1etproof/post/3592362c-cf60-40e1-9c15-47c0f7e30f7b/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202021-08-21%20%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB%203.00.15.png](https://images.velog.io/images/pu1etproof/post/3592362c-cf60-40e1-9c15-47c0f7e30f7b/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202021-08-21%20%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB%203.00.15.png)
    

## 8. 식사하는 철학자 문제 : 교착상태를 다루는 문제

이 문제는 병행 프로그래밍의 어려움을 다시금 느끼게 될 수 있는 공유 자원을 통한 협동의 대표적인 문제이다.

![https://images.velog.io/images/pu1etproof/post/f45ddb70-d529-4ac1-9b81-d006d3ec402f/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202021-08-21%20%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB%203.04.39.png](https://images.velog.io/images/pu1etproof/post/f45ddb70-d529-4ac1-9b81-d006d3ec402f/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202021-08-21%20%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB%203.04.39.png)

### 문제 정의

- 원탁 테이블 가운데에는 스파게티가 담긴 큰 그릇이 하나있다.
- 철학자가 개인적으로 사용하는 접시가 5개 있고, 접시 양쪽에는 포크가 있다. (결국 테이블 위에는 5개의 포크가 존재한다.)
- 철학자는 배가 고프면 자신의 정해진 위치로 가서 큰 그릇에 담긴 스파게티를 자신의 접시에 담아 먹는다.
- 철학자들은 스프게티를 먹기 위해 반드시 포크 2개를 사용해야 한다.
- 고려되어야 할 것
    - 임계영역이 지켜져야 한다 : 여러 철학자가 동시에 같은 포크를 사용할 수 없다. (상호 배제)
    - 교착상태나 기아에 빠져서는 안된다 : 어떤 철학자도 굶어 죽어서는 안된다
    - **즉, 교착상태도 없어야 하고, 굶어 죽지도 않아야 한다.**

### 1) 세마포어를 이용한 해결 방법 - 교착상태 발생

![https://images.velog.io/images/pu1etproof/post/cccefa3c-0145-4a59-bef3-cd27e7c6f976/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202021-08-23%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%204.35.20.png](https://images.velog.io/images/pu1etproof/post/cccefa3c-0145-4a59-bef3-cd27e7c6f976/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202021-08-23%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%204.35.20.png)

```
1. wait(fork[i]) : 철학자는 우선 왼쪽에 있는 포크를 집는다.
2. wait(for[i+1]) : 이후 오른쪽에 있는 포크를 집는다.
3. eat() : 식사를 한다.
4. sigal(fork[i+1]), signal(fork[i]) : 식사 이후, 철학자는 두 개의 포크들을 식탁에 다시 내려놓는다.
```

이러한 방법은 교착상태를 유발한다는 문제점이 있다.즉, 모든 철학자들이 동시에 식탁에 앉고 동시에 왼쪽 포크를 집었다고 가정하면, 오른쪽 포크를 집으려 해도 거기에는 포크가 없게 된다. 결국 아무도 식사를 하지 못하게 되는 것이다.

> 그 외 방법
> 
> - 교착상태를 피하기 위해 포크를 5개 더 구입하는 방법
> - 포크 하나로 스파게티 먹는 법을 가르치는 방법
> - 한 번에 최대 4명까지만 식탁에 앉을 수 있게 제한하는 방법

### 2) 세마포어를 이용한 다른 해결 방법 - 교착상태 발생하지 않음

- 한 번에 최대 4명까지만 식탁에 앉을 수 있게 제한하는 방법

![https://images.velog.io/images/pu1etproof/post/88342d91-698c-4e7d-ab60-9703bea94544/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202021-08-23%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%204.33.10.png](https://images.velog.io/images/pu1etproof/post/88342d91-698c-4e7d-ab60-9703bea94544/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202021-08-23%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%204.33.10.png)

### 3) 모니터를 이용한 해결 방법

![https://images.velog.io/images/pu1etproof/post/2260d5a2-3794-4f4f-ae7b-c0f1af526e31/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202021-08-21%20%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB%203.19.50.png](https://images.velog.io/images/pu1etproof/post/2260d5a2-3794-4f4f-ae7b-c0f1af526e31/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202021-08-21%20%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB%203.19.50.png)

### 4) 병행성 기법 사례 - 유닉스, 리눅스

### 유닉스 병행성 기법

- 프로세스 간 통신 (IPC : InterProcess Communication)
    - 시그널(Signal)
    - 파이프(Pipe)
        
        ![https://images.velog.io/images/pu1etproof/post/9c1032fa-a4f8-4a90-9aaa-a44ac3984acb/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202021-08-21%20%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB%203.22.57.png](https://images.velog.io/images/pu1etproof/post/9c1032fa-a4f8-4a90-9aaa-a44ac3984acb/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202021-08-21%20%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB%203.22.57.png)
        
    - 메시지 전달(Message passing)
        
        ![https://images.velog.io/images/pu1etproof/post/93432f75-43b2-4699-8f64-b1b1e6059181/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202021-08-21%20%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB%203.23.18.png](https://images.velog.io/images/pu1etproof/post/93432f75-43b2-4699-8f64-b1b1e6059181/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202021-08-21%20%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB%203.23.18.png)
        
    - 공유 메모리(Shared Memory)
        
        ![https://images.velog.io/images/pu1etproof/post/b00b0307-58b5-4e22-8bb6-bde3289dcc6a/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202021-08-21%20%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB%203.23.40.png](https://images.velog.io/images/pu1etproof/post/b00b0307-58b5-4e22-8bb6-bde3289dcc6a/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202021-08-21%20%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB%203.23.40.png)
        
    - 세마포어(Semaphore)

### 5) 리눅스 병행성 기법

- 유닉스 병행성 기법 지원
- 원자적 연산 : 중단/간섭없이 실행되는 작업이다.
- 스핀락(spinlock)
    - 한 번에 하나의 스레드만 스핀락을 획득할 수 있다.
    - 다른 스레드는 lock을 획득할 수 있을 때까지 계속 시도(spinning)한다.
    - 기본 스핀락, 읽기-쓰기 스핀락
- 세마포어
    - 이진 세마포어, 카운팅 세마포어, 판독기/작성기(reader-writer) 세마포어
- 장벽(barrier)
    - 명령이 실행되는 순서를 강제로 시행하기 위해