# 11-1. I/O Management

## I/O Device

---

- 외부장치의 3가지 카테고리
    1. Humman readable
        
        : 컴퓨터 사용자와의 통신에 적합
        
        ex) 프린터, 터미널, 디스플레이, 키보드, 마우스…
        
    2. Machine readable(머신끼리 통신)
        
        : 전자 장비와의 통신에 적합
        
        ex) 디스크 드라이브, USB 키, 센서, 컨트롤러
        
    3. Communication
        
        : 원격 장치와의 통신에 적합
        
        ex) 모뎀, …
        

### I/O 디바이스들의 차이점 → 차이점이 너무 많아서 일관적이게 다룰수가 없음.

- Data Rate (데이터 전송률) : 전송 레이트 (ex LAN 카드 100Gbps)
- Application : 장치가 어디에 사용되는지 (용도)
- Complexity of Control (제어의 복잡성) : 디스크 IO는 접근에 대해 훨씬 복잡하다 → IO 모듈을 통해 제어한다
- Unit of Transfer (전송 단위) : 터미널 IO에서는 character단위, 디스크 IO에서는 block 이상의 단위
- Data Representation (데이터 표현) : 장치마다 데이터를 표현하는 방법(encoding scheme)가 다르게 사용될 수 있다.
- Error Conditions (오류 상태) : 오류 성격, 보고 결과 및 방법 등등

### I/O function의 조직

I/O를 수행하는 세가지 방법

1. **Programmed I/O**
    - 프로세서가 프로세스를 대신해서 I/O 모듈에 명령을 요청한다.
    - 프로세스는 작업이 완료될 때까지 대기한다. → 효율 저하
2. **Interrupt-driven I/O**
    - 프로세서가 프로세스를 대신해서 I/O 명령을 실행한다
        - non-blocking : 인터럽트가 발생하기 전까지 해당 프로세스의 다른 명령을 수행한다.
        - blocking : 현재 프로세스를 block시키고 다른 프로세스로 스위칭한다.
3. **Direct Memory Access (DMA)** 
    - 메인메모리와 I/O 모듈 간에 직접 데이터 교환을 제어하는 것을 DMA가 처리
    - 프로세서는 DMA 모듈에 요청을 보내고 프로세서는 할거 하다가, 전송이 완료되면 DMA가 인터럽트를 통해서 프로세서에게 보내면 프로세서는 완료되었음을 알게 된다.

### I/O 기능의 발전

1. 프로세서가 모든 주변장치를 직접 제어
2. 프로세서가 직접 하지 않고 컨트롤러나 I/O 모듈을 사용 → 프로세서는 외부 디바이스에 대한 복잡한 제어를 할 필요가 없다 (분리된다)
3. 인터럽트를 사용해서 효율성을 증가시켰다.
4. I/O 모듈이 발전하여 DMA를 통해서 직접적으로 메모리를 접근한다.
5. I/O 모듈이 더 발전하여 특수목적 명령어 집합을 가진 분리된 프로세서 같은 기능을 제공한다.
6. I/O 모듈이 더 발전하여 자체적인 메모리를 가지며 독립적인 컴퓨터가 되었다.

### I/O 장비에 관련된 OS 설계 이슈

1. **효율성 (Efficiency)**
    - IO 명령어들은 매우 느리기 때문에 병목구간이 된다.
    - 특히 많이 사용되는 디스크 I/O에 대해 관심 있다.
2. **범용성 (Generality)**
    - 모든 장치를  일관된 방법으로 관리하는 것이 바람직하다.
        - 프로세스가 IO 장치를 보는 방식과 OS가 IO 작업을 관리하는 방식이 일관적이어야 한다.
    - 하지만 장치의 다양성으로 인해 범용성을 보장하기 어렵다
    - **따라서 계층적, 모듈화 방식을 이용한다.**

- I/O의 계층 : 범용성을 위해서
    
    ![스크린샷 2022-06-12 02.19.57.png](11-1%20I%20O%20Management%206a92f2fada574da48aa16ab95aea7c86/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-06-12_02.19.57.png)
    
    - 주변장치(논리 → 물리 → 실질적 제어)
        1. Logical I/O : 장치를 논리적 자원으로 취급한다. (세부사항에는 관심 없다)
            
            open, close, read, write 명령
            
        2. Device I/O : 해당하는 입출력 명령, 채널 명령 등으로 변경된다.
        3. Scheduling & Control : 실질적으로 하드웨어를 제어를 구현(실제적인 구현부)
    - 파일 시스템
        1. Directory Management : file descriptor를 통해서 파일의 정보를 하드웨어에서 식별 가능한 식별자로 변경한다.
        2. File system : 위에서 보내준 식별자를 이용해 파일의 논리적 구조 및 open, close, read, write 명령을 다룬다.
            
            Logical I/O와 유사하다.
            
        3. Physical Organization : 논리적인 파일 참조를 외부 저장장치의 물리적인 주소로 변경한다.
    

### I/O Buffering

만약 프로세스 영역에서 I/O 모듈로 직접 전송된다면 프로세스는 전송 중에는 Block이 되기때문에 Swap out이 되지 않을 수 있다.(메인메모리에 눈치없이 계속 있게된다) → 비효율 발생

why? IO 작업을 위해 불러오고 있는데 메모리에서 나가면 데이터 전송이 불가하니까

해결법 : Block이 안되고 미리 읽어온다면??? → 바로바로 버퍼링이지롱~~~

Buffering : 미리 메모리에 미리 읽어온다 → 오버헤드 및 비효율 방지

- 미리 읽어와서 쓰기요청이 있으면 메모리에서 바로 꺼내서 줌. 자 내가 먼저 읽어와놨어~
- 그러면 Block도 안되고 아주 편하게 쓸 수 있다.
- 쓰기 요청이 이루어진 후에 일정 시간이 지나면 출력 전송을 수행한다.(이게 버퍼링)
    
    (이후에도 다시 수정이 이루어질 수 있다는 가정하에 조금 기다려주는거임 원래 한번 쓰기 요청한 것은 계속 쓰기를 요청할 가능성이 높다는 전제하에… 그래서 좀 기다리다가 일정시간이 지나면!!! 한번에 이제 모아서 쓕 하고 전송한다.)
    

- I/O 장치의 두 가지 타입
    - **Block-Oriented** (블록 지향) 장치
        
        : 고정 크기(Data의 끝을 아는 놈) (ex 디스크, USB …)
        
    - **Stream-Oriented** (스트림 지향) 장치
        
        : Data의 끝을 알 수 없는 경우 (ex 터미널, 프린터, 키보드, 마우스 ..  )
        
        바이트 스트림으로 데이터를 송수신한다.
        

1. 버퍼가 없다면 (No buffer)
    
    ![스크린샷 2022-06-12 02.52.10.png](11-1%20I%20O%20Management%206a92f2fada574da48aa16ab95aea7c86/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-06-12_02.52.10.png)
    
    - OS가 직접 장치에 접근하고 프로세스에게 전송한다
        
        → 프로세스는 각 IO가 완료될 때까지 기다려야 한다.(Swap out안된다!!)
        
        블락되더라도 스왑하지 않고 기다린다. → 비효율
        
2. 단일 버퍼 (Single buffer) → 매우 효율적인 기법 
    
    ![스크린샷 2022-06-12 02.52.25.png](11-1%20I%20O%20Management%206a92f2fada574da48aa16ab95aea7c86/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-06-12_02.52.25.png)
    
    - User 프로세스가 IO 요청을 하면 OS가 커널 메모리에 버퍼 하나를 할당한다.
    - 그러고 IO 디바이스가 버퍼에 보내게된다. 그러면 User Process는 직접 IO를 할당받지 않았으니까 Swap Out할 수 있다. → 이제 그러면 활용도가 상당히 높아진다.
    - 입력 받는 동안에는 프로세스를 일시 중지시킨다 (스왑해도 된다)
        - 입력이 끝나면 (커널 메모리에 있는) 버퍼에 저장된 결과를 준다
    - 출력(output)의 경우에도 프로세스는 IO 디바이스에 바로 요청하는 것이 아니라 버퍼에 출력 라인을 배치하고 계속 처리를 할 수 있다(요청해놓고 스왑아웃해도 다른놈이 와서 받아간다)
    
    ⇒ 성능을 향상시킨다
    
3. 이중 버퍼 (Double buffer)
    
    ![스크린샷 2022-06-12 02.56.27.png](11-1%20I%20O%20Management%206a92f2fada574da48aa16ab95aea7c86/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-06-12_02.56.27.png)
    
    - 싱글 버퍼에서는 [IO 장치 → OS] / [OS → 프로세스] 동안 두 가지를 동시에 못한다.
    - 버퍼를 하나 추가하여 프로세스가 기다리지 않고 즉시 받을 수 있다.
4. 원형 버퍼 (Circular buffer)
    
    ![스크린샷 2022-06-12 02.58.25.png](11-1%20I%20O%20Management%206a92f2fada574da48aa16ab95aea7c86/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-06-12_02.58.25.png)
    
    - 프로세스가 빠른 IO 작업을 수행하는 경우에는 이중 버퍼로 부족할 수 있다.
    - 따라서 두 개 이상의 버퍼를 순환하여 사용하는 방법