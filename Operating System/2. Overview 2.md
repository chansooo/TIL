# Overview 2

## 운영체제의 목적

- 운영체제의 목적
    1. 편리성
    2. 효율성
    3. 발전성
    

## 운영체제 발전

### 운영체제 발전의 용이성

- Hardware Upgrades & New types of hardware (하드웨어 업그레이드와 새로운 형태의 하드웨어): 소프트웨어를 지원하는 하드웨어가 업그레이드 되어야 소프트웨어도 사용할 수 있음
- New Service(새로운 서비스): 새로운 서비스를 제공하기 위해서는 운영체제가 확장되어야함.
- Fixes(버그 수정): 모든 운영체제는 결함을 가지고 있고, 이 결함은 시간이 지나 발견되므로 운영체제가 발전해야한다.

## 운영체제 발전의 단계

1. Serial Processing(순차처리)
2. Simple Batch Systems(단순 일괄 처리 시스템)
3. Multiprogrammed Batch Systems(멀티프로그래밍 일괄처리 시스템)
4. Time sharing System(시분할 시스템)

### Serial Processing(순차처리)

- 초기의 컴퓨터
    - 운영체제 없음
        - 프로그래머는 컴퓨터 하드웨어와 직접 소통
    - 컴퓨터는 디스플레이 발광체, 토글 스위치, 일부 형태의 입력 장치, 프린터로 구성된 콘솔에서 운영됨
    - 사용자는 “순차적으로” 접근할 수 있었다.
- 문제점
    - Scheduling(스케줄링)
        - 기계에 소프트웨어를 설치하기 위해 sign-up sheet를 통해 기계 사용 시간을 예약해야했음.
            - 1시간 예약하고 30분 쓰면 30분 날림
    - Setup time(준비시간)
        - 프로그램을 실행하도록 설정하는데 많은 시간이 걸림
            - 작업(job)이라 부르는 단일 프로그램을 수행하기 위해서는 컴파일러와 소스코드를 메모리에 적재하고 컴파일된 프로그램을 저장장치에 저장한 다음 바이너리 실행파일과 공용함수들을 함께 적재하는 등 적재하는데 시간이 많이 걸림
- 사용자가 컴퓨터를 순차적으로 접근하기 때문에 순차처리라고 함.

### Simple Batch System(단순 일괄처리 시스템)

- 초창기 컴퓨터는 매우 비쌈 → 프로세서 효율성 최대로 올리는 것이 중요
- 컴퓨터의 이용률을 향상시키기 위해 개발됨
- 모니터
    - 단순 일괄처리 기법의 기반이 되는 아이디어
    - 소프트웨어임
    - 결과
        - 사용자가 직접 프로세스에 접근할 필요 없어짐
        - job을 함께 일괄처리해서 컴퓨터 오퍼레이터에 제출하고 오퍼레이터는 작업들을 순서래도 모아 모니터가 처리할 수 있도록 전체 작업 묶음(batch)를 입력 장치에 넣음
        - 프로그램의 실행이 완료되면 제어가 모니터로 다시 넘어가게 함으로써 자동으로 프로그램을 적재할 수 있음
- 모니터 관점
    - 모니터는 일련의 event들을 제어함
    - 이를 위해 Resident Monitor(상주 모니터)라는 메모리에 모니터의 대부분이 항상 수행 가능한 상태로 있어야 한다.
    - 모니터가 작업(job)읽고 제어 줌.
    - 끝나면 모니터에게 제어 넘김
        
        ![Screen Shot 2022-04-05 at 8.18.11 PM.png](Overview%202%2089123/Screen_Shot_2022-04-05_at_8.18.11_PM.png)
        
    
- 필요한 하드웨어 기능
    1. Memory protection(메모리 보호)
        - 수행 중인 사용자 프로그램이 모니터를 포함하는 메모리 영역을 변경하지 못하도록
    2. Timer(타이머)
        - 한  job이 프로세서를 독접하지 못하도록
        - 설정된 시간이 경과하면 제어는 모니터로 돌아감
    3. Privileged instructions
        - 다음에 실행할 프로그램 적재를 모니터에서만 할 수 있도록
        - 그래서 사용자 프로그램이 입출력 연산을 하고자 할 때는 모니터가 대신 하도록 요청해야함
    4. Interrupts(인터럽트)
        - 융통성 있게 사용자 프로그램에게 제어를 넘겨주거나 넘겨받을 수 있게 됨
    
    → 메모리 보로와 특권 명령어의 도립으로 Operation Mode라는 개념이 생김
    

**Modes of Operation**

- User mode(사용자 모드)
    - 사용자 프로그램은 사용자 모드에서 실행됨
    - 메모리의 특정 영역 사용할 수 X
    - 명령어 접근 제한적
- Kernel Mode(커널 모드)
    - 시스템 모드라도고 불림
    - 특권 명령어 수행 가능
    - 보호 메모리 영역도 접근 가능
    - 모니터가 커널 모드에서 실행됨

Simple Batch system Overhead

1. 사용자프로그램과 모니터가 번갈아 수행되므로 메모리의 일부를 모니터가 계속 차지해야함
2. 모니터가 실행되는 약간의 시간이 필요함

그래도 컴퓨터 이용률을 향상시킬 수 있다~

 

### Multiprogrammed Batch System(멀티프로그래밍 일괄처리 시스템)

- 필요성이 대두된 이유
    - IO 처리가 프로세서보다 느리다
    - 자동 job sequencing에도 불구하고 프로세서가 자주 idle상태에 있음
    - 그 예시
        - read: 15us
        - execute: 1us
        - write 15us
        
        → toal 31us
        
        → percent CPU utilization = 1/31 = 3.2%
        
        → 97퍼센트가 CPU가 일하지 못하고 idle한 시간
        
- 한 작업이 IO처리를 대기해야할 때 프로세서는 입출력을 대기할 것 같지 않은 다른 작업으로 제어를 넘김
    - 운영체제와 두 개의 사용자 프로그램을 적재할 수 있는 큰 메모리 공간이 존재한다고 가정
    
    → 멀티프로그래밍
    
    ![Screen Shot 2022-04-05 at 8.35.13 PM.png](Overview%202%2089123/Screen_Shot_2022-04-05_at_8.35.13_PM.png)
    

### Time-Sharing System(시분할 시스템)

- 프로세서 시간을 여러 사용자들이 공유
- 여러 대화형 작업을 처리하는데 사용할 수 있음
- 대화형 멀티프로그래밍 == 시분할 기법
    - 왜냐면 다수의 사용자가 처리기 시간을 공유하기 때문에
- 각 사용자 프로그램이 짧은 시간동안 번갈아 수행되도록 해주는 OS를 통해 다수의 사용자가 동시에 시스템에 접근할 수 있게 함

|  | 일괄처리 멀티 프로그래밍 | 시분할 |
| --- | --- | --- |
| 주요 목적 | 프로세서 이용률의 최대화 | 응답시간의 최소화 |
| 운영체제에 대한 명령어 소스 | 작업과 함께 제공되는 작업 제어 언어 명령어 | 터미널에서 입력되는 명령어 |

## 주요 성과

- OS는 지금까지 개발된 소프트웨어 중 가장 복잡한 부분임
- 주요 개발 발전 사항
    - 프로세스
    - 메모리 관리
    - 정보보호 및 보안
    - 스케줄링 및 리소스 관리
    - 다양한 OS 아키텍쳐 접근

### 프로세스

- 운영체제 구조의 핵심
- 다양한 정의
    - 수행 중인 프로그램
    - 컴퓨터 상에서 수행 중인 프로그램의 인스턴스
    - 프로세스에 할당되어 수행될 수 있는 개체(entity)
    - 소스코드를 컴퓨터가 인식할 수 있도록 명령된 상태
- 검출하기 어려운 에러의 네가지 주요 원인
    - 부적절한 동기화
        - io처리 완료 후 신호가 분실되거나 중복돼서 문제생기는 것
    - 상호배제 실패
        - 동시에 공유 자원의 사용을 시도해서 갱신이 되지 않은 채 사용되는 것
    - 비결정적인(nondeterminate)프로그램 연산
        - 인터리빙 방식으로 실행시킬 때 동일한 공유 메모리 영역에 예측 불가능한 방식으로 overwrite를 함으로써 프로그램의 수행을 서로 방해할 수 있음
        
        → 서로 다른 프로그램들의 실행 순서가 특정 프로그램의 수행 결과에 영향을 미칠 수 있음
        
    - 교착상태(deadlock)
        - 두 개 이상의 프로그램이 서로 상대방의 프로그램에 할당된 자원의 방충(release)를 기다리면서 대기하면 서로 방출할 때까지 기다려서 하염없이 기다릴 수 있음
- 세 가지 구성요소(이를 통해 체계적으로 제어해서 에러를 방지할 수 있음)
    - 수행가능한 프로그램
    - 프로그램 수행에 필요한 데이터(변수, 작업공간, 버퍼 등)
    - 프로그램 execution context(수행 문맥)
        - 이 내부 정보는 프로세스에 허용되지 않음
- 필수적인 execution context(수행 문맥)
    - OS가 프로세스를 감독하고 제어하기 위해 필요한 내부적인 데이터
    - 프로세스 주소 공간으로부터 분리되어있음(왜냐면 프로세스가 아무지 자기 것이더라도 마음대로 참조하면 안 되는 정보를 가지고 있기 때문에)
    - 프로세스를 관리하고 프로세서가 프로세스를 정확히 수행하는데 필요한 모든 필수 정보들을 포함함
        - 따라서 PC나 데이터 레지스터같은 다양한 레지스터 내용플 포함
    - 프로세스를 처리하는데 유용한 정보 포함
        - 프로세스 우선순위
        - 프로세스가 어떤 입출력 사건이 완료되기를 기다리고 있는지 등
        

## 메모리 관리

![Screen Shot 2022-04-05 at 9.12.12 PM.png](Overview%202%2089123/Screen_Shot_2022-04-05_at_9.12.12_PM.png)

- 어떤 순간의 프로세스 전체 상태는 execution context(문맥)에 포함됨
- 프로세스 목록에는 프로세스를 포함하는 메모리의 블록의 위치에 대한 포인터가 포함됨
- 프로세스 인덱스 레지스터는 현재 프로세서를 제어하는 프로세스의 프로세스 목록에 대한 인덱스를 포함

- 저장장치를 관리하는데 있어서의 5사지 주요 책무
    - 프로세스 분리(isolation)
        - 메모리 겹치지 않도록
    - 자동 할당 및 관리
        - 메모리 영역은 필요할 때마다 계층 구조를 따라 동적으로 할당돼야하고 사용자 개입 없이 자동으로 이뤄져야함
    - 모듈식 프로그래밍 지원
        - 프로그래머가 프로그램 모듈을 정의, 작성, 삭제할 수 있어야하고 그 크기를 동적으로 변경할 수 있어야 한다.
    - 보호 및 엑세스 제어
        - 무결성을 위협할 수 있지만 메모리의 일부는 접근할 수 있도록 허용해야함.
    - 영구적 저장

### 정보 보호와 보안

- 조직을 위협하는 본질은 조직의 환경에 따라 달라짐
- 문제는 컴퓨터 시스템과 그 안에 저장된 정보에 대한 접근을 제어하는 것과 관련있음
- 보안 조치에 대한 4가지 범주
    1. availability: 가용성
        - 시스템이 중지되지 않게 하는 것과 관련
    2. confidentiality: 기밀성
        - 접근 권한이 부여되지 않은 데이터를 사용자가 읽지 못하도록
    3. data integrity: 데이터 무결성
        - 데이터가 불법적으로 수정되지 못하게 보호하는 것
    4. authenticity: 신빙성
        - 사용자 신원과 메시지나 데이터의 유효성에 대한 적절한 인증과 관련
        

### 스케줄링과 자원 관리

- OS의 핵심 작업은 manage와 그들의 사용을 schedule하는 것
- 스케줄링에서 주요하게 고려해야할 3가지
    - Fairness: 공정성
        - 특정 자원을 사용하고자 경쟁하는 모든 프로세스들은 그 자원을 대체적으로 공정하게 접근할 수 있어야함
    - Differential responsiveness: 반응시간 차등화
        - 다른 서비스 요건을 지닌 작업 클래스들을 구별해야하면서도, 모든 요구 조건들을 포괄적으로 만족시킬 수 있도록 할당 및 스케줄링해야함
    - Efficiency: 효율성
        - 작업 처리량을 극대화하며, 반응시간을 최소화하고, 시분할의 경우 가능한 많은 수의 사용자를 동시에 수용하기 위해 애써야함

## 최근 운영체제로의 발전

### 다양한 아키텍처 접근 방식

- Microkernel architecture
- Multithreading
- Symmetric Multiprocessing(대칭형 멀티프로세싱)
- Distributed operating systems(분산 운영체제)
- Object-oriented design(객체지향 설계)

### Microkernel architecture

- 최소한의 필요한 기능만 커널에 포함시킴
    - 주소 공간
    - 프로세스 간 통신(IPC: interprocess communication)
    - 기본적인 스케줄링
- 그 빡의 서비스는 서버라 불리는 프로세스에 의해 제공
    
    → 커널과 서버의 개발이 분리될 수 있음
    
- 목적
    - 구현 쉬워짐
    - 구조적 유연성( 서버, 커널 떼서 개발 가능)
    - 이식성 향상
    - 

### Multithreading

- 실행하는 프로세스를 동시에 수행될 수 있는 쓰레드들로 분할하는 기법
- 순차적이지 않은 독립적인 여러 작업을 수행하는데 유용함
    - ex) 요청이 들어오면 이를 처리하는 DB서버
- 스레드 간 전환이 프로세스 간 전환보다 오버헤드가 적다

| 쓰레드 | 프로세스 |
| --- | --- |
| 작업의 디스패치 단위 | 하나 이상의 쓰레드와 관련 시스템 자원들(코드, 데이터를 포함함 메모리, 파일, 장치)로 구성 |
| 프로세스 문맥과 자체 데이터 영역으로서의 스택을 포함 | 동시에 수행되는 스레드들로 구성 |
| 순차적으로 수행 |  |
| 프로세서가 다른 스레드로 문맥 교환할 수 있도록 인터럽트 당할 수 있음 |  |
| 프로세스 내의 스레드들이 자원들을 공유 |  |

### Symmetric Multiprocessing(SMP): 대칭형 멀티프로세싱

![Screen Shot 2022-04-06 at 12.04.22 AM.png](Overview%202%2089123/Screen_Shot_2022-04-06_at_12.04.22_AM.png)

- Tightly-coupled systems: 강결합 시스템
    - 두개 이상의 동일한 프로세서가 하나의 공유하는 메인 메모리에 연결되고 모든 IO장치에 대한 엑세스 권한을 가짐
    - 모든 프로세서를 동등하게 취급하는 단일 운영체제 인스턴스에 의해 제어
    - 다중 프로세서의 존재가 유저에게 투명하게 공개
- 잠재적 이점
    - Performance(성능)
        - 동시에 1개 이상 프로세스가 병렬로 실행되면 하나 이상의 프로세스들이 각각 다른 프로세서 상에서 동시에 수행될 수 있음
    - Availability(가용성)
        - 하나의 프로세서가 결함이 생겨도 시스템이 다운되지 않음
    - Incremental Growth(점진적 확장)
        - 사용자가 성능 향상을 위해 프로세스를 추가하면 성능을 향상시킬 수 잇음
    - Scaling(크기 조절)
        - 판매자들은 시스템을 구성하는 처리기의 수에 따라 가격과 성능이 다른 다양한 제품을 공급할 수 있음
- 멀티프로그래밍과 멀티프로세싱의 차이
    
    ![Screen Shot 2022-04-06 at 12.12.04 AM.png](Overview%202%2089123/Screen_Shot_2022-04-06_at_12.12.04_AM.png)
    
    | Multiprogramming | Multiprocessing |
    | --- | --- |
    | 1개 프로세서 | 여러개 프로세서 |
    | interleaving | interleaving & overlapping |
    | 하나의 CPU 번갈아 씀 | 물리적으로 다른 프로세서에 할당되어 함께 진행됨 |

### OS Design

- Disrtibuted Operating System(↔ SMP): 분산운영체제
    - 별도의 독립된 컴퓨터로 구성된 약결합 시스템(Loosely-coupled systems)
    - 단일 메모리 공간과 단일 보조 메모리 공간을 사용하는 것처럼 느끼게 해줌
- Object-Oriented Design: 객체지향 설계
    - 네가지 기본 개념
        - Inheritance(상속)
        - encapsulation(캡슐화)
        - abstraction(추상화)
        - polymorphism(다형성)
    - 프로그래머가 시스템 무결성을 방해하지 않고 OS를 커스터마이즈 할 수 있음
    - 분산도구나 환전한 형대의 분산 운영체제의 개발을 용이하게 함
    

## Fault Tolerance(고장감내, 결함허용)

- 하드웨어나 소프트웨어 경함이 있음에도 불구하고 계속 정상 작동할 수 있는 능력
- 일반적으로 어느정도의 중복성을 포함
- 시스템의 신뢰도를 놓이기 위한 것
    - 비용이나 퍼포먼스가 수반됨
- 얼마나 중요한지에 따라 fault tolerance의 범위를 결정해야함

### 결함의 유형

- Permanent(영구적)
    - 한번 발생하면 영구적으로 존재
    - 고치거나 새로 갈아주지 않으면 고장 유지
- Temporary(일시적)
    - 모든 동작 환경에서 항상 나타나지는 않음
    1. Teansient(단발적): 한 번 발생하고 마는 유형
    2. Intermittent(일시적): 예상할 수 없는 시점에 수차례 발생하는 유형
    

### 결함 대응 방법

1. Spatial(physical) redundancy: 공간적(물리적) 여분 설비
    - 여분의 부품 여러개를 설치
    - 한 부품이 결함 발생하면 여부능로 준비한 부품들이 백업의 역할을 하도록
2. Temporal redundancy: 시간적 여분 설비
    - 오류 발생하면 동일한 기능이나 동작을 계속 반복할 수 있도록 하는 방식
    - 영구적 결함에는 효과X, 일시적 결함에는 큰 효과
3. Information redundancy: 정보 여분 설비
    - 데이터를 복사해두거나 비트 오류를 감지하고 복구할 수 있는 코드를 데이터에 덧붙이는 방식
    

## MS Window 개요

![Screen Shot 2022-04-06 at 12.48.01 AM.png](Overview%202%2089123/Screen_Shot_2022-04-06_at_12.48.01_AM.png)

커널모드 요소들

- Executive(실행부)
    - 메모리 관리, 프로세스 및 스레드 관리, 보안, IO, 프로세스 간 통신과 같은 핵심적인 OS 서비스 포함
- Kernel(커널)
    - 프로세스의 실행 제어
    - 스레드 스케줄링, 프로세스 전환, 예외 및 인터럽트 처리, 다중 프로세서 동기화
- Hardware Abstraction Layer(HAL)
    - 일반적인 하드웨어 명령 및 응답을 특정 플랫폼에 적합한 것으로 매핑하고 플랫폼별 하드웨어 차이로부터 OS를 독립시킴
- Device Drivers
    - 실행부의 기능을 확장하는 동적 라이브러리
    - 들어있는 것
        - 사용자의 IO함수 호출을 특정 하드웨어 장치에 대한 입출력 요청으로 변환해주는 장치 드라이버
        - 파일 시스템 구현하기 위한 소프트웨어 컴포넌트
        - 네트워크 프로토콜
        - 기타 커널 보드에서 수행돼야하는 시스템 확장 모듈
- Windowing and Graphic System
    - 창, 사용자 인터페이스 제어, 드로잉 등을 다루는 GUI기능 구현
    

## Traditional UNIX Systems

- Bell Labs에서 개발
- 1970년에 PDP-7에서 운용 가능
- 모든 컴퓨터에서 사용 가능한 OS
- 다음 마일스톤: C언어로 UNIX를 프로그래밍
- 대중화된 버전은 1976년 버전 6
- 버전 7이 대부분 현대 UNIX 시스템들의 조상
- AT&T 이외의 시스템 중 가장 중요한 것은 UNIX BSD(Berkeley Software Distribution)로, 먼저 PDP에서 실행된 다음 VAX 컴퓨터에서 실행됨
- 전통적인 유닉스 커널
    
    ![IMG_8203.HEIC](Overview%202%2089123/IMG_8203.heic)
    

## Linux

- IBM PC용 unix 변형으로 시작
- Linus Tovalds가 만듬 초기버전 1991년 인터넷에 게시
- 오늘날 완전한 기능을 갖춘 모든 플랫폼에서 실행 가능한 UNIX 시스템
- 고도로 모듈화되고 쉽게 구성
- 오픈소스 라이센스로 출시
    - 누구나 실행 수정 재배포 ,판매가능
    

## Android Operating System

- Andrew Rubin이 원래 터치스크린 모바일 장치(예: 스마트폰 및 태블릿 컴퓨터)용으로 설계된 Linux 기반 시스템
- 모바일 기기 및 IoT용으로 가장 많이 사용되는 OS\
- Android에는 AOSP(Android 오픈 소스 프로젝트) 소스 코드를 사용하여 자체 수정 버전의 운영 체제를 개발 및 배포하는 개발자 및 애호가로 구성된 활발한 커뮤니티가 있음
- 2005년 Google에 인수된 Android Inc.에서 개발
- Android의 오픈 소스 특성이 성공의 열쇠
- 2008년 9월 첫 상용 버전(Android 1.0) 출시
    
    ![Screen Shot 2022-04-06 at 1.20.57 AM.png](Overview%202%2089123/Screen_Shot_2022-04-06_at_1.20.57_AM.png)