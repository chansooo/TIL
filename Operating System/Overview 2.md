# Overview 2

## 운영체제의 목적

- 운영체제의 목적
    1. 편리성
    2. 효율성
    3. 발전성
    

## 운영체제 발전

### 운영체제 발전의 용이성

- Hardware Upgrades & New types of hardware (하드웨어 업그레이드와 새로운 형태의 하드웨어): 소프트웨어를 지원하는 하드웨어가 업그레이드 되어야 소프트웨어도 사용할 수 있음
- New Service(새로운 서비스): 새로운 서비스를 제공하기 위해서는 운영체제가 확장되어야함.
- Fixes(버그 수정): 모든 운영체제는 결함을 가지고 있고, 이 결함은 시간이 지나 발견되므로 운영체제가 발전해야한다.

## 운영체제 발전의 단계

1. Serial Processing(순차처리)
2. Simple Batch Systems(단순 일괄 처리 시스템)
3. Multiprogrammed Batch Systems(멀티프로그래밍 일괄처리 시스템)
4. Time sharing System(시분할 시스템)

### Serial Processing(순차처리)

- 초기의 컴퓨터
    - 운영체제 없음
        - 프로그래머는 컴퓨터 하드웨어와 직접 소통
    - 컴퓨터는 디스플레이 발광체, 토글 스위치, 일부 형태의 입력 장치, 프린터로 구성된 콘솔에서 운영됨
    - 사용자는 “순차적으로” 접근할 수 있었다.
- 문제점
    - Scheduling(스케줄링)
        - 기계에 소프트웨어를 설치하기 위해 sign-up sheet를 통해 기계 사용 시간을 예약해야했음.
            - 1시간 예약하고 30분 쓰면 30분 날림
    - Setup time(준비시간)
        - 프로그램을 실행하도록 설정하는데 많은 시간이 걸림
            - 작업(job)이라 부르는 단일 프로그램을 수행하기 위해서는 컴파일러와 소스코드를 메모리에 적재하고 컴파일된 프로그램을 저장장치에 저장한 다음 바이너리 실행파일과 공용함수들을 함께 적재하는 등 적재하는데 시간이 많이 걸림
- 사용자가 컴퓨터를 순차적으로 접근하기 때문에 순차처리라고 함.

### Simple Batch System(단순 일괄처리 시스템)

- 초창기 컴퓨터는 매우 비쌈 → 프로세서 효율성 최대로 올리는 것이 중요
- 컴퓨터의 이용률을 향상시키기 위해 개발됨
- 모니터
    - 단순 일괄처리 기법의 기반이 되는 아이디어
    - 소프트웨어임
    - 결과
        - 사용자가 직접 프로세스에 접근할 필요 없어짐
        - job을 함께 일괄처리해서 컴퓨터 오퍼레이터에 제출하고 오퍼레이터는 작업들을 순서래도 모아 모니터가 처리할 수 있도록 전체 작업 묶음(batch)를 입력 장치에 넣음
        - 프로그램의 실행이 완료되면 제어가 모니터로 다시 넘어가게 함으로써 자동으로 프로그램을 적재할 수 있음
- 모니터 관점
    - 모니터는 일련의 event들을 제어함
    - 이를 위해 Resident Monitor(상주 모니터)라는 메모리에 모니터의 대부분이 항상 수행 가능한 상태로 있어야 한다.
    - 모니터가 작업(job)읽고 제어 줌.
    - 끝나면 모니터에게 제어 넘김
        
        ![Screen Shot 2022-04-05 at 8.18.11 PM.png](Overview%202%2089123/Screen_Shot_2022-04-05_at_8.18.11_PM.png)
        
    
- 필요한 하드웨어 기능
    1. Memory protection(메모리 보호)
        - 수행 중인 사용자 프로그램이 모니터를 포함하는 메모리 영역을 변경하지 못하도록
    2. Timer(타이머)
        - 한  job이 프로세서를 독접하지 못하도록
        - 설정된 시간이 경과하면 제어는 모니터로 돌아감
    3. Privileged instructions
        - 다음에 실행할 프로그램 적재를 모니터에서만 할 수 있도록
        - 그래서 사용자 프로그램이 입출력 연산을 하고자 할 때는 모니터가 대신 하도록 요청해야함
    4. Interrupts(인터럽트)
        - 융통성 있게 사용자 프로그램에게 제어를 넘겨주거나 넘겨받을 수 있게 됨
    
    → 메모리 보로와 특권 명령어의 도립으로 Operation Mode라는 개념이 생김
    

**Modes of Operation**

- User mode(사용자 모드)
    - 사용자 프로그램은 사용자 모드에서 실행됨
    - 메모리의 특정 영역 사용할 수 X
    - 명령어 접근 제한적
- Kernel Mode(커널 모드)
    - 시스템 모드라도고 불림
    - 특권 명령어 수행 가능
    - 보호 메모리 영역도 접근 가능
    - 모니터가 커널 모드에서 실행됨

Simple Batch system Overhead

1. 사용자프로그램과 모니터가 번갈아 수행되므로 메모리의 일부를 모니터가 계속 차지해야함
2. 모니터가 실행되는 약간의 시간이 필요함

그래도 컴퓨터 이용률을 향상시킬 수 있다~

 

### Multiprogrammed Batch System(멀티프로그래밍 일괄처리 시스템)

- 필요성이 대두된 이유
    - IO 처리가 프로세서보다 느리다
    - 자동 job sequencing에도 불구하고 프로세서가 자주 idle상태에 있음
    - 그 예시
        - read: 15us
        - execute: 1us
        - write 15us
        
        → toal 31us
        
        → percent CPU utilization = 1/31 = 3.2%
        
        → 97퍼센트가 CPU가 일하지 못하고 idle한 시간
        
- 한 작업이 IO처리를 대기해야할 때 프로세서는 입출력을 대기할 것 같지 않은 다른 작업으로 제어를 넘김
    - 운영체제와 두 개의 사용자 프로그램을 적재할 수 있는 큰 메모리 공간이 존재한다고 가정
    
    → 멀티프로그래밍
    
    ![Screen Shot 2022-04-05 at 8.35.13 PM.png](Overview%202%2089123/Screen_Shot_2022-04-05_at_8.35.13_PM.png)
    

### Time-Sharing System(시분할 시스템)

- 프로세서 시간을 여러 사용자들이 공유
- 여러 대화형 작업을 처리하는데 사용할 수 있음
- 대화형 멀티프로그래밍 == 시분할 기법
    - 왜냐면 다수의 사용자가 처리기 시간을 공유하기 때문에
- 각 사용자 프로그램이 짧은 시간동안 번갈아 수행되도록 해주는 OS를 통해 다수의 사용자가 동시에 시스템에 접근할 수 있게 함

|  | 일괄처리 멀티 프로그래밍 | 시분할 |
| --- | --- | --- |
| 주요 목적 | 프로세서 이용률의 최대화 | 응답시간의 최소화 |
| 운영체제에 대한 명령어 소스 | 작업과 함께 제공되는 작업 제어 언어 명령어 | 터미널에서 입력되는 명령어 |

## 주요 성과

- OS는 지금까지 개발된 소프트웨어 중 가장 복잡한 부분임
- 주요 개발 발전 사항
    - 프로세스
    - 메모리 관리
    - 정보보호 및 보안
    - 스케줄링 및 리소스 관리
    - 다양한 OS 아키텍쳐 접근

### 프로세스

- 운영체제 구조의 핵심
- 다양한 정의
    - 수행 중인 프로그램
    - 컴퓨터 상에서 수행 중인 프로그램의 인스턴스
    - 프로세스에 할당되어 수행될 수 있는 개체(entity)
    - 소스코드를 컴퓨터가 인식할 수 있도록 명령된 상태
- 검출하기 어려운 에러의 네가지 주요 원인
    - 부적절한 동기화
        - io처리 완료 후 신호가 분실되거나 중복돼서 문제생기는 것
    - 상호배제 실패
        - 동시에 공유 자원의 사용을 시도해서 갱신이 되지 않은 채 사용되는 것
    - 비결정적인(nondeterminate)프로그램 연산
        - 인터리빙 방식으로 실행시킬 때 동일한 공유 메모리 영역에 예측 불가능한 방식으로 overwrite를 함으로써 프로그램의 수행을 서로 방해할 수 있음
        
        → 서로 다른 프로그램들의 실행 순서가 특정 프로그램의 수행 결과에 영향을 미칠 수 있음
        
    - 교착상태(deadlock)
        - 두 개 이상의 프로그램이 서로 상대방의 프로그램에 할당된 자원의 방충(release)를 기다리면서 대기하면 서로 방출할 때까지 기다려서 하염없이 기다릴 수 있음
- 세 가지 구성요소(이를 통해 체계적으로 제어해서 에러를 방지할 수 있음)
    - 수행가능한 프로그램
    - 프로그램 수행에 필요한 데이터(변수, 작업공간, 버퍼 등)
    - 프로그램 execution context(수행 문맥)
        - 이 내부 정보는 프로세스에 허용되지 않음
- 필수적인 execution context(수행 문맥)
    - OS가 프로세스를 감독하고 제어하기 위해 필요한 내부적인 데이터
    - 프로세스 주소 공간으로부터 분리되어있음(왜냐면 프로세스가 아무지 자기 것이더라도 마음대로 참조하면 안 되는 정보를 가지고 있기 때문에)
    - 프로세스를 관리하고 프로세서가 프로세스를 정확히 수행하는데 필요한 모든 필수 정보들을 포함함
        - 따라서 PC나 데이터 레지스터같은 다양한 레지스터 내용플 포함
    - 프로세스를 처리하는데 유용한 정보 포함
        - 프로세스 우선순위
        - 프로세스가 어떤 입출력 사건이 완료되기를 기다리고 있는지 등
        

## 메모리 관리

![Screen Shot 2022-04-05 at 9.12.12 PM.png](Overview%202%2089123/Screen_Shot_2022-04-05_at_9.12.12_PM.png)

- 어떤 순간의 프로세스 전체 상태는 execution context(문맥)에 포함됨
- 프로세스 목록에는 프로세스를 포함하는 메모리의 블록의 위치에 대한 포인터가 포함됨
- 프로세스 인덱스 레지스터는 현재 프로세서를 제어하는 프로세스의 프로세스 목록에 대한 인덱스를 포함

- 저장장치를 관리하는데 있어서의 5사지 주요 책무
    - 프로세스 분리(isolation)
        - 메모리 겹치지 않도록
    - 자동 할당 및 관리
        - 메모리 영역은 필요할 때마다 계층 구조를 따라 동적으로 할당돼야하고 사용자 개입 없이 자동으로 이뤄져야함
    - 모듈식 프로그래밍 지원
        - 프로그래머가 프로그램 모듈을 정의, 작성, 삭제할 수 있어야하고 그 크기를 동적으로 변경할 수 있어야 한다.
    - 보호 및 엑세스 제어
        - 무결성을 위협할 수 있지만 메모리의 일부는 접근할 수 있도록 허용해야함.
    - 영구적 저장

### 정보 보호와 보안

- 조직을 위협하는 본질은 조직의 환경에 따라 달라짐
- 문제는 컴퓨터 시스템과 그 안에 저장된 정보에 대한 접근을 제어하는 것과 관련있음
- 보안 조치에 대한 4가지 범주
    1. availability: 가용성
        - 시스템이 중지되지 않게 하는 것과 관련
    2. confidentiality: 기밀성
        - 접근 권한이 부여되지 않은 데이터를 사용자가 읽지 못하도록
    3. data integrity: 데이터 무결성
        - 데이터가 불법적으로 수정되지 못하게 보호하는 것
    4. authenticity: 신빙성
        - 사용자 신원과 메시지나 데이터의 유효성에 대한 적절한 인증과 관련
        

### 스케줄링과 자원 관리

- OS의 핵심 작업은 manage와 그들의 사용을 schedule하는 것
- 스케줄링에서 주요하게 고려해야할 3가지
    - Fairness: 공정성
        - 특정 자원을 사용하고자 경쟁하는 모든 프로세스들은 그 자원을 대체적으로 공정하게 접근할 수 있어야함
    - Differential responsiveness: 반응시간 차등화
        - 다른 서비스 요건을 지닌 작업 클래스들을 구별해야하면서도, 모든 요구 조건들을 포괄적으로 만족시킬 수 있도록 할당 및 스케줄링해야함
    - Efficiency: 효율성
        - 작업 처리량을 극대화하며, 반응시간을 최소화하고, 시분할의 경우 가능한 많은 수의 사용자를 동시에 수용하기 위해 애써야함