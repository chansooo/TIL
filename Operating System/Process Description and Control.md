# Process Description and Control

## 학습 목표

- 프로세스를 정의하고, 프로세스들과 프로세스 제어 블록(PCB)들 사이의 관계를 이해할 수 있다
- 프로세스 상태의 개념을 설명하고 프로세스들의 살태 전이에 대해 설명할 수 있다.
- 프로세스들을 관리하기 위해, 운영체제가 사용하는 자료구조 및 자료구조 구성요소들의 목적을 나열하고 설명할 수 있다
- 운영체제에서 프로세스 제어를 위한 요구사항들을 평가할 수 있다
- OS 코드의 실행에 관련된 이슈들을 이해할 수 있다.
- UNIX SVR4의 프로세스 관리 기법을 설명할 수 있다

## 프로세스란?

- 프로세스의 두 필수적인 요소
    - 프로그램 코드
        - 컴파일러에 의해 바이너리 코드로 바뀐 아이
    - 데이터의 집합(코드와 연계된)
        - PCB에 포함됨
- 프로세서가 프로그램 코드를 실행하기 시작할 때 이 실행 개체를 프로세스라고 함

### 프로세스 요소

프로세스는 다음을 포함한 여러가지 요소들에 의해 고유하게 식별될 수 있음

- Identifier(식별자): 다른 프로세스로부터 구별하게 해주는 유일한 식별자, PID(Process ID)
- State(상태): run? 대기? block?
- Priority(우선순위): 상대적인 우선순위 수준
- Program Counter(PC): 프로그램에서 다음에 수행될 명령어 주소. 이걸 하나씩 더하면서 명령어 진행
- Memory Pointer: 프로그램 코드 및 데이터, 다른 프로세스들과 함께 공유되는 메모리 블록들에 대한 메모리 포인터 정보
- Context data(문맥 데이터): 프로세스가 수행 중일 때, 프로세서의 레지스터에 존재하는 데이터
- I/O status information(입출력 상태정보): 프로세스에 할당된 입출력 장치, 프로세스에 의해 사용 중인 파일들의 리스트 등을 포함
- Acounting information(과금 정보): 사용된 프로세서 시간 및 클록 시간, 시간 제한, 계정 번호 들을 포함

→ 보통 이 모든 정보들이 PCB(프로세스 제어블록)이라는 자료구조에 저장

### Process Control Block(PCB)

- 주요 역할
    - 수행 프로세스를 인터럽트 한 후 나중에 그 인터럽트가 발생되지 않은 것처럼 프로세스 수행을 재개할 수 있도록 충분한 정보를 유지하는 것
- 운영체제로 하여금 다수의 프로세스를 지원하고 멀티프로세싱을 제공할 수 있게 해주는 주요 도구
- 프로세스 요소들을 포함
- 운영체제에 의해 만들어지고 관리됨

## Process Status(프로세스 상태)

- 프로세서 관점으로 볼 때 프로세서는 프로그램  카운터 레지스터(PC register)값에 의해 결정된 순서에 따라 명령어를 수행함
- Trace(실행 궤적)
    - 해당 프로세스에 대해 실행되는 명령어의 리스트. sequence of instructions that execute for that process
    - 프로세서의 실행의 특징은 다양한 프로세스들의 trace가 어떻게 인터리빙되는지를 보임으로써 특징지을 수 있음
- Dispatcher
    - 처리기를 한 프로세스로부터 다른 프로세스로 교체해주는 프로그램

![Screen Shot 2022-04-06 at 1.51.31 AM.png](Process%20De%2064035/Screen_Shot_2022-04-06_at_1.51.31_AM.png)

![Screen Shot 2022-04-06 at 1.52.14 AM.png](Process%20De%2064035/Screen_Shot_2022-04-06_at_1.52.14_AM.png)

- 어둡게 나타난 부분은 디스패처
- 프로세스 B가 4개 명령어 실행하고 IO 요청한다고 가정

### Two-State Process Model

- 프로세스는 Not Running 또는 Running, 두 가지 상태 중 하나를 가짐.
- 정상 종료든 비정상 종료든 Queue에 들어가게 되고 대기하다가 순서따라 프로세서에 들어가 Run한다

![Screen Shot 2022-04-06 at 1.56.28 AM.png](Process%20De%2064035/Screen_Shot_2022-04-06_at_1.56.28_AM.png)

## 프로세스 생성과 종료

### 프로세스 생성 이유

| New batch job(새로운 일괄처리 작업) | 일괄처리 환경에서 작업이 제출될 때 프로세스 생성 |
| --- | --- |
| Ineractive logon(대화형 로그온) | 새로운 사용자가 터미널에 로그온할 때 |
| 서비스를 제공하기 위해 운영체제가 생성 | 사용자가 대기할 필요 없도록 어떤 기능을 수행할 프로세스를 생성해줌 |
| 기존 프로세스에 의한 생성(spawn) | 모듈화를 위해서, 병렬성을 이용하기 위해서 사용자 프로그램이 프로세스 생성을 명령함 |

### 프로세스 생성(Spawn, not creation)

- Process Spawning
    - 운영체제가 어떤 프로세스의 명시적인 요청에 의해 새로운 프로세스를 생성하는 것
- Parent process
    - 다른 프로세스를 생성하는 프로세스
- Child process
    - 만들어진 프로세스
    

### 프로세스 종료 이유

![IMG_8204.HEIC](Process%20De%2064035/IMG_8204.heic)

첫번째: 정상종료

뒤에서 두개: 부모에 의해

나머지: 오류, 이벤트성

### 프로세스 종료

- 프로세스가 완료되었음을 나타내는 수단이 있어야함
- batch job(일괄 작업)에는 종료를 위한 halt 명령이나 명시적 os서비스 호출이 있어야함
- interactive application(대화형 프로그램)의 경우 사용자의 작업은 프로세스가 완료될 때 표시됨

### Five-State Process Model

![Screen Shot 2022-04-06 at 2.12.02 AM.png](Process%20De%2064035/Screen_Shot_2022-04-06_at_2.12.02_AM.png)

- Two-State Model에서는 Not Running상태의 프로세스들 중 준비가 되지 않은 친구들이 있을 수 있다.
- 그래서 block되지 않았으며 큐에 가장 오래된 아이를 뽑기 위해 나온 모델
- Not Running 상태를 Ready상태와 Blocked상태로 분할
- 5가지 상태
    - Running
        - 현재 수행 중인 프로세스.
    - Ready
        - 기회가 주어지면 수해오딜 준비가 되어 있는 프로세스
    - Blocked/Waiting
        - 입출력 연산 완료와 같은 어떤 이벤트가 발생할 때까지 수행될 수 없는 프로세스
    - New
        - 막 생성되어서 ready에 진입이 허용되지 않은 프로세스
        - 보통 pcb가 생기더라도 바로 메모리에 올라가지 않음
    - Exit
        - 프로세스 수행이 halt(중지) 되거나 어떤 이유로 abort(중단)되었기때문에 운영체제에 의해 수행가능 프로세스 풀에서 방출된 프로세스
- 프로젝트의 규모가 커지면 blocked queue를 하나만 두는 것보다 이벤트 별로 나눌 수 있는데 그것이 Multiple blocked queues(↔ single blocked queue)
    
    ![Screen Shot 2022-04-06 at 2.17.11 AM.png](Process%20De%2064035/Screen_Shot_2022-04-06_at_2.17.11_AM.png)
    

### Suspended Processes(보류된 프로세스)

- Swapping
    - 필요한 이유
        - 입출력 장치가 너무 느리기 때문에 프로세서의 대부분의 시간이 idle(유휴)해버리기 때문에
        - idle한 아이들을 빼고 다른 아이들을 돌리기 위해 메모리에 더 올리려면 더 큰 메모리 공간이 필요해버리는데 불필요하다
    - 메인 메모리에서 디스트로 모든 프로세스의 일부나 전체를 옮기는 것
    - 메모리에 있는 프로세스 중에 ready 상태가 하나도 없으면 os는 블록된 프로세스들 중에 하나를 디스크로 내보내고 suspend queue(보류 큐)에 집어넣어버림
    - suspend queue에는 메모리로부터 잠시 쫒겨진 프로세스들이 존재
    - 메모리에 공간이 생겼으므로 보류큐에 있는 다른 프로세스를 메모리로 들이거나 새로운 프로세스 요청을 받아들이고 run함
    - swapping 자체가 io작업이므로 문제가 더 악화될 수도 있음.  하지만 swapping에 사용되는 disk io가 가장 빠른 io기때문에 괜찮을거야~
    
- one suspend state
    - suspend만 추가
- Two suspend States
    - ready: 프로세스 메모리에 있고 바로 수행 가능
    - blocked: 메모리에 있고 이벤트 기다리는 애
    - blocked/suspend: 프로세스가 보조기억장치에 있고 이벤트 기다리는 애
    - ready/suspend: 프로세스가 보조기억장치에 있지만 메모리로 올라가면 바로 수행될 수 있음