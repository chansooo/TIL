# Process Description and Control

## 학습 목표

- 프로세스를 정의하고, 프로세스들과 프로세스 제어 블록(PCB)들 사이의 관계를 이해할 수 있다
- 프로세스 상태의 개념을 설명하고 프로세스들의 살태 전이에 대해 설명할 수 있다.
- 프로세스들을 관리하기 위해, 운영체제가 사용하는 자료구조 및 자료구조 구성요소들의 목적을 나열하고 설명할 수 있다
- 운영체제에서 프로세스 제어를 위한 요구사항들을 평가할 수 있다
- OS 코드의 실행에 관련된 이슈들을 이해할 수 있다.
- UNIX SVR4의 프로세스 관리 기법을 설명할 수 있다

## 프로세스란?

- 프로세스의 두 필수적인 요소
    - 프로그램 코드
        - 컴파일러에 의해 바이너리 코드로 바뀐 아이
    - 데이터의 집합(코드와 연계된)
        - PCB에 포함됨
- 프로세서가 프로그램 코드를 실행하기 시작할 때 이 실행 개체를 프로세스라고 함

### 프로세스 요소

프로세스는 다음을 포함한 여러가지 요소들에 의해 고유하게 식별될 수 있음

- Identifier(식별자): 다른 프로세스로부터 구별하게 해주는 유일한 식별자, PID(Process ID)
- State(상태): run? 대기? block?
- Priority(우선순위): 상대적인 우선순위 수준
- Program Counter(PC): 프로그램에서 다음에 수행될 명령어 주소. 이걸 하나씩 더하면서 명령어 진행
- Memory Pointer: 프로그램 코드 및 데이터, 다른 프로세스들과 함께 공유되는 메모리 블록들에 대한 메모리 포인터 정보
- Context data(문맥 데이터): 프로세스가 수행 중일 때, 프로세서의 레지스터에 존재하는 데이터
- I/O status information(입출력 상태정보): 프로세스에 할당된 입출력 장치, 프로세스에 의해 사용 중인 파일들의 리스트 등을 포함
- Acounting information(과금 정보): 사용된 프로세서 시간 및 클록 시간, 시간 제한, 계정 번호 들을 포함

→ 보통 이 모든 정보들이 PCB(프로세스 제어블록)이라는 자료구조에 저장

### Process Control Block(PCB)

- 주요 역할
    - 수행 프로세스를 인터럽트 한 후 나중에 그 인터럽트가 발생되지 않은 것처럼 프로세스 수행을 재개할 수 있도록 충분한 정보를 유지하는 것
- 운영체제로 하여금 다수의 프로세스를 지원하고 멀티프로세싱을 제공할 수 있게 해주는 주요 도구
- 프로세스 요소들을 포함
- 운영체제에 의해 만들어지고 관리됨

## Process Status(프로세스 상태)

- 프로세서 관점으로 볼 때 프로세서는 프로그램  카운터 레지스터(PC register)값에 의해 결정된 순서에 따라 명령어를 수행함
- Trace(실행 궤적)
    - 해당 프로세스에 대해 실행되는 명령어의 리스트. sequence of instructions that execute for that process
    - 프로세서의 실행의 특징은 다양한 프로세스들의 trace가 어떻게 인터리빙되는지를 보임으로써 특징지을 수 있음
- Dispatcher
    - 처리기를 한 프로세스로부터 다른 프로세스로 교체해주는 프로그램

![Screen Shot 2022-04-06 at 1.51.31 AM.png](Process%20De%2064035/Screen_Shot_2022-04-06_at_1.51.31_AM.png)

![Screen Shot 2022-04-06 at 1.52.14 AM.png](Process%20De%2064035/Screen_Shot_2022-04-06_at_1.52.14_AM.png)

- 어둡게 나타난 부분은 디스패처
- 프로세스 B가 4개 명령어 실행하고 IO 요청한다고 가정

### Two-State Process Model

- 프로세스는 Not Running 또는 Running, 두 가지 상태 중 하나를 가짐.
- 정상 종료든 비정상 종료든 Queue에 들어가게 되고 대기하다가 순서따라 프로세서에 들어가 Run한다

![Screen Shot 2022-04-06 at 1.56.28 AM.png](Process%20De%2064035/Screen_Shot_2022-04-06_at_1.56.28_AM.png)

## 프로세스 생성과 종료

### 프로세스 생성 이유

| New batch job(새로운 일괄처리 작업) | 일괄처리 환경에서 작업이 제출될 때 프로세스 생성 |
| --- | --- |
| Ineractive logon(대화형 로그온) | 새로운 사용자가 터미널에 로그온할 때 |
| 서비스를 제공하기 위해 운영체제가 생성 | 사용자가 대기할 필요 없도록 어떤 기능을 수행할 프로세스를 생성해줌 |
| 기존 프로세스에 의한 생성(spawn) | 모듈화를 위해서, 병렬성을 이용하기 위해서 사용자 프로그램이 프로세스 생성을 명령함 |

### 프로세스 생성(Spawn, not creation)

- Process Spawning
    - 운영체제가 어떤 프로세스의 명시적인 요청에 의해 새로운 프로세스를 생성하는 것
- Parent process
    - 다른 프로세스를 생성하는 프로세스
- Child process
    - 만들어진 프로세스
    

### 프로세스 종료 이유

![IMG_8204.HEIC](Process%20De%2064035/IMG_8204.heic)

첫번째: 정상종료

뒤에서 두개: 부모에 의해

나머지: 오류, 이벤트성

### 프로세스 종료

- 프로세스가 완료되었음을 나타내는 수단이 있어야함
- batch job(일괄 작업)에는 종료를 위한 halt 명령이나 명시적 os서비스 호출이 있어야함
- interactive application(대화형 프로그램)의 경우 사용자의 작업은 프로세스가 완료될 때 표시됨

### Five-State Process Model

![Screen Shot 2022-04-06 at 2.12.02 AM.png](Process%20De%2064035/Screen_Shot_2022-04-06_at_2.12.02_AM.png)

- Two-State Model에서는 Not Running상태의 프로세스들 중 준비가 되지 않은 친구들이 있을 수 있다.
- 그래서 block되지 않았으며 큐에 가장 오래된 아이를 뽑기 위해 나온 모델
- Not Running 상태를 Ready상태와 Blocked상태로 분할
- 5가지 상태
    - Running
        - 현재 수행 중인 프로세스.
    - Ready
        - 기회가 주어지면 수해오딜 준비가 되어 있는 프로세스
    - Blocked/Waiting
        - 입출력 연산 완료와 같은 어떤 이벤트가 발생할 때까지 수행될 수 없는 프로세스
    - New
        - 막 생성되어서 ready에 진입이 허용되지 않은 프로세스
        - 보통 pcb가 생기더라도 바로 메모리에 올라가지 않음
    - Exit
        - 프로세스 수행이 halt(중지) 되거나 어떤 이유로 abort(중단)되었기때문에 운영체제에 의해 수행가능 프로세스 풀에서 방출된 프로세스
- 프로젝트의 규모가 커지면 blocked queue를 하나만 두는 것보다 이벤트 별로 나눌 수 있는데 그것이 Multiple blocked queues(↔ single blocked queue)
    
    ![Screen Shot 2022-04-06 at 2.17.11 AM.png](Process%20De%2064035/Screen_Shot_2022-04-06_at_2.17.11_AM.png)
    

### Suspended Processes(보류된 프로세스)

- Swapping
    - 필요한 이유
        - 입출력 장치가 너무 느리기 때문에 프로세서의 대부분의 시간이 idle(유휴)해버리기 때문에
        - idle한 아이들을 빼고 다른 아이들을 돌리기 위해 메모리에 더 올리려면 더 큰 메모리 공간이 필요해버리는데 불필요하다
    - 메인 메모리에서 디스트로 모든 프로세스의 일부나 전체를 옮기는 것
    - 메모리에 있는 프로세스 중에 ready 상태가 하나도 없으면 os는 블록된 프로세스들 중에 하나를 디스크로 내보내고 suspend queue(보류 큐)에 집어넣어버림
    - suspend queue에는 메모리로부터 잠시 쫒겨진 프로세스들이 존재
    - 메모리에 공간이 생겼으므로 보류큐에 있는 다른 프로세스를 메모리로 들이거나 새로운 프로세스 요청을 받아들이고 run함
    - swapping 자체가 io작업이므로 문제가 더 악화될 수도 있음.  하지만 swapping에 사용되는 disk io가 가장 빠른 io기때문에 괜찮을거야~
    
- one suspend state
    - suspend만 추가
- Two suspend States
    - ready: 프로세스 메모리에 있고 바로 수행 가능
    - blocked: 메모리에 있고 이벤트 기다리는 애
    - blocked/suspend: 프로세스가 보조기억장치에 있고 이벤트 기다리는 애
    - ready/suspend: 프로세스가 보조기억장치에 있지만 메모리로 올라가면 바로 수행될 수 있음
    

## Process Description(프로세스 기술)

### 운영체제 제어 구조

- 운영체제가 프로세스와 자원들을 관리하기 위해서는 이들 각가에 대한 현재 상태를 나타내는 정보를 가지고 있어야함
- 이를 위해 관리하고자 하는 각 개체에 대한 정보를 테이블로 구성해서 유지
- 운영체제가 제어해야할 서로 다른 4가지 타입(테이블로 가지고 있음)
    
    ![Screen Shot 2022-04-06 at 1.32.07 PM.png](Process%20De%2064035/Screen_Shot_2022-04-06_at_1.32.07_PM.png)
    
    - 메모리
    - 입출력 장치
    - 파일
    - 프로세스

### 메모리 테이블

- 메모리와 보조기억장치 모두의  track을 유지하기 위해 사용됨
- 메모리 일부는 OS가 사용하도록 예약되어 있고, 나머지는 프로세스들이 사용할 수 있음
- 프로세스들은 가상 메모리나 간단한 스와핑 기법을 사용하여 보조기억장치 내에 유지되기도 함
- 메모리 테이블이 가지고 있어야 하는 정보
    - 프로세스에게 할당된 메모리
    - 프로세스에게 할당된 보조 기억 장치
    - 어떤 프로세스가 특정 공유 메모리 영역에 접근 가능하다는 속성 등과 같은 메모리나 가상메모리 블록들에 대한 보호 속성(프로세스가 특정 영역 접근 가능?)
    - 가상 메모리를 관리하기 위해 필요한 정보

### 입출력 테이블

- 입출력 장치와 컴퓨터 시스템의 채널들을 관리하기 위해 운영체제에서 사용됨
- 입출력 동작 진행 중일 때 OS는 입출력 동작의 진행 상태와 입출력 전송의 풀발지와 목적지로서 사용되는 주기억장치 내의 위치를 알아야함

### 파일 테이블

- 저장된 정보
    - 파일의 존재 여부
    - 보조기억장치에 저장된 파일의 위치
    - 현재 상태
    - 그 밖의 속성에 대한 정보 저장(속성값 등(read가능해))
- OS는 파일에 대해서 거의 모름
    - 어떤 운영체제는 파일 관리의 대부분을 OS에서 하기도 함

### 프로세스 테이블

- 프로세스 관리를 위해 유지됨
- 직간접적으로 메모리, I/O, 파일에 대한 참조가 있어야함(위의 테이블들은 모두 프로세스테이블을 위한 것~)
- OS가 처음에 테이블들을 생성할지 어떻게 알고 있지?
    - OS가 메모리 용량, io 장치 현황, 어떻게 식별할 수 있는지 등 기본 정보를 할고 있어야함
- 테이블 자체는 OS에서 엑세스 할 수 있어야하므로 메모리 관리 대상임

## 프로세스 제어 구조

### 프로세스 관리를 위해 OS가 알아야할 것들

- 위치: 프로세스가 어디 있는지
- 프로세스의 속성: 프로세스ID(PID), 프로세스 상태 등을 알아야 관리할 수 있음

### Process Location(프로세스 위치)

- 프로세스는 실행할 프로그램이나 프로그램의 집합을 포함해야함
- 프로세스는 해당 프로세스의 프로그램과 데이터를 보유하기에 충분한 메모리로 구성됨
- 프로그램 실행은 보통 프로시저 호출들의 track과 프로시저 사이의 매개변수를 유지하는데 사용되는 스택을 포함함

### Process Attributes(프로세스 속성)

- OS는 해당 프로세스를 제어하기 위해 속성들을 사용함
- 속성들의 집합을 PCB(Process Control Block)라고 함
- 프로그램과 데이터, 스택, 속성들의 집합을 프로세스 이미지(Process image)라고 함

### Process Image의 원소

- User Data
    - 사용자 공간에서 수정 가능한 부분, 프로그램 데이터와 사용자 스택 영역, 수정될 수 있는 프로그램 포함
- User Program
    - 실행할 프로그램
- Stack
    - 각 프로세스는 하나 이상의 시스템 스택을 가짐.
    - 스택은 프로시저와 시스템 호출에 필요한 매개변수와 호출 수조(복귀 주소)를 저장하는데 사용됨
    - → 파라미터 저장, 필요한 데 사용
- PCB(Process Control Block)
    - 프로세스를 제어하기 위해 운영체제가 필요로 하는 데이터
    - 속성값들을 보유

## 프로세스 속성

### PCB 내에 있는 정보들의 범주

- 프로세스 식별
- 프로세스 상태 정보
- 프로세스 제어 정보

### 프로세스 식별(Process identification)

- Identifier(식별자)
    - PCB에는 아래와 같은 숫자로 된 식별자가 존재
        - 이 프로세스의 식별자
        - 이 프로세스의 부모 프로세스 식별자
        - 사용자 식별자

### 처리기 상태 정보(Processor State Information)

- User-Visible Registers(사용자가 사용 가능한 레지스터)(General Purpose Register)
    - 프로세서가 사용자 모드에서 수행하는 기계 언어에 의해 참조될 수 있는 레지스터.
- Control and Status Register(제어 레지스터 & 상태 레지스터)
    - PC(Program Counter)
        - 다음에 반입(fetch)할 명령어의 주소를 가짐
    - condition codes(조건 코드)
        - 가장 최근에 수행된 산술 또는 논리 연산의 결과
    - Status Information(상태 정보)
        - 인터럽트 가능/불가 플래그들과 수행 모드(커널 or 유저)를 가짐
- Stack Pointer
    - 각 프로세스는 하나 이상의 스택을 가짐
    - 스택이 저장하는 것
        - 프로시저
        - 시스템 호출의 매개변수와 호풀 주소
        
        스택 포인터는 스택의 top을 가리킴
        

### 프로세스 제어 정보(Process Control Information)

- Scheduling and State Information
    
    운영체제가 스케줄링 기능을 수행하기 위해 필요한 정보들
    
    - Process State(프로세스 상태)
        - 수행되기 위해 스케줄될 프로세스의 준비상황
        - running, ready, waiting, halted
    - Priority
        - 프로세스의 스케줄링 우선순위를 나타내기 위해 하나 이상의 필드가 사용됨
        - 여러 개의 값이 요구될 수 있음(기본값, 현재값, 허용가능 최대치)
    - Scheduling-related information(스케줄링과 관련된 정보)
        - 프로세스가 대기하고 있었던 시간, 마지막에 수행되었던 시간 등
    - Event
        - 프로세스가 재시작되기 전에 기다리고 있던 사건을 알려줌
        - 그럼 PC랑 뭐가 다르니?
- Data Structuring(자료구조화)
    - 프로세스는 큐, 링 혹은 다른 자료구조로 다른 프로세스와 연결될 수 있음(부모 자식 구조와 같이)
    - 다른 프로세스를 가리키는 포인터를 지원
- Interprocess Communication(IPC, 프로세스간 통신)
    - 여러 플래그와 시그널, 메시지 등이 독립된 두 개의 프로세스 사이의 통신과 연관될 수 있음.
    - 이 정보의 일부 혹은 전부가 PCB 내에 유지됨
- Process Privileges(프로세스 권한)
    - 프로세스가 어디까지 접근 가능한지, 어떤 instruction까지 실행이 간으한지 권한
- Memory Management
    - 프로세스에 할당된 것들(가상메모리를 나타내는 세그먼트, 페이지 테이블)에 대한 포인터 가짐
- Resource Ownership and Utilization(자우너의 소유권과 이용률)
    - 프로세스가 제어하는 자원들을 파일처럼 표시될 수 있음
    - 이용률에 대한 이력 정보 또한 가지고 있음.
    - 이 정보들은 스케줄러에 의해 사용됨
    

## PCB의 역할

- 운영체제에서 가장 중요한 자료구조
- 운영체제에게 필요한 모든 정보들이 들어있음
- 운영체제의 모든 모듈에 의해 읽혀지고 수정될 수 있음
- PCB의 집합은 운영체제의 상태를 정의한다
- PCB들을 PID로 구별한다.
    
    ![Screen Shot 2022-04-08 at 5.20.48 PM.png](Process%20De%2064035/Screen_Shot_2022-04-08_at_5.20.48_PM.png)
    
- virtual memory에서의 프로세스들의 구조는 연속해서 보이지만 물리적인 공간은 사실 분리되어 있다.

## 프로세스 제어

### 수행 모드

- User Mode
    - 권한 낮음
    - 일반적으로 user program들이 이 모드로 수행됨
- Kernel Mode
    - 시스템 모드, 제어 모드 등으로 불림
    - 더 높은 권한
    - 운영체제 커널과 관련
    

### 운영체제 커널의 기능

- Process Management
    - 프로세스 생성과 종료
    - 프로세스 스케줄링과 디스패칭
    - 프로세스 교환
    - 프로세스 동기화와 프로세스 간 통신 지원
    - PCB 관리
- Memory Management
    - 프로세스에 주소 공간 할당
    - 스와핑
    - 페이지와 세그먼트 관리
- I/O Management
    - 버퍼 관리
    - 프로세스에 입출력 채널과 장치 할당
- Support Functions(지원 기능)
    - 인터럽트 핸들링
    - 어카운팅
    - 모니터링

### 프로세스 생성

1. 새로운 프로세스를 위해 PID(프로세스 식별자) 할당. 
    - 이때, 새로운 항목이 주요 프로세스 테이블에 추가됨. 프로세스 테이블은 프로세스마다 하나의 항목을 유지함
2. 프로세스를 위한 공간 할당.
    - 프로세스 이미지의 모든 요소들이 여기에 저장.
3. PCB 초기화
    - PID 부분에는 해당 프로세스의 ID와 부모 프로세스의 ID가 들어감
    - 프로세스 상태 정보는 대부분 0으로 초기화
        - PC는 프로그램 진입점으로, 스택 포인터는 프로세스 스택 경계로 초기화
    - 프로세스 제어 정보는 표준 기본 값과 프로세스 위해 요청된 속성에 근거하여 초기화
    - 자원에 대한 명시적 요청 없으면 자원(io장치, 파일 등)을 소유하지 않게 됨
4. 프로세스가 어떤 링크에 들어가야 하는지 세팅
    1. 레디큐, 러닝큐 등등..
5. 다른 자료구조 생성

### 프로세스 교환