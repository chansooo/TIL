# Process Description and Control

## 학습 목표

- 프로세스를 정의하고, 프로세스들과 프로세스 제어 블록(PCB)들 사이의 관계를 이해할 수 있다
- 프로세스 상태의 개념을 설명하고 프로세스들의 살태 전이에 대해 설명할 수 있다.
- 프로세스들을 관리하기 위해, 운영체제가 사용하는 자료구조 및 자료구조 구성요소들의 목적을 나열하고 설명할 수 있다
- 운영체제에서 프로세스 제어를 위한 요구사항들을 평가할 수 있다
- OS 코드의 실행에 관련된 이슈들을 이해할 수 있다.
- UNIX SVR4의 프로세스 관리 기법을 설명할 수 있다

## 프로세스란?

- 프로세스의 두 필수적인 요소
    - 프로그램 코드
        - 컴파일러에 의해 바이너리 코드로 바뀐 아이
    - 데이터의 집합(코드와 연계된)
        - PCB에 포함됨
- 프로세서가 프로그램 코드를 실행하기 시작할 때 이 실행 개체를 프로세스라고 함

### 프로세스 요소

프로세스는 다음을 포함한 여러가지 요소들에 의해 고유하게 식별될 수 있음

- Identifier(식별자): 다른 프로세스로부터 구별하게 해주는 유일한 식별자, PID(Process ID)
- State(상태): run? 대기? block?
- Priority(우선순위): 상대적인 우선순위 수준
- Program Counter(PC): 프로그램에서 다음에 수행될 명령어 주소. 이걸 하나씩 더하면서 명령어 진행
- Memory Pointer: 프로그램 코드 및 데이터, 다른 프로세스들과 함께 공유되는 메모리 블록들에 대한 메모리 포인터 정보
- Context data(문맥 데이터): 프로세스가 수행 중일 때, 프로세서의 레지스터에 존재하는 데이터
- I/O status information(입출력 상태정보): 프로세스에 할당된 입출력 장치, 프로세스에 의해 사용 중인 파일들의 리스트 등을 포함
- Acounting information(과금 정보): 사용된 프로세서 시간 및 클록 시간, 시간 제한, 계정 번호 들을 포함

→ 보통 이 모든 정보들이 PCB(프로세스 제어블록)이라는 자료구조에 저장

### Process Control Block(PCB)

- 주요 역할
    - 수행 프로세스를 인터럽트 한 후 나중에 그 인터럽트가 발생되지 않은 것처럼 프로세스 수행을 재개할 수 있도록 충분한 정보를 유지하는 것
- 운영체제로 하여금 다수의 프로세스를 지원하고 멀티프로세싱을 제공할 수 있게 해주는 주요 도구
- 프로세스 요소들을 포함
- 운영체제에 의해 만들어지고 관리됨

## Process Status(프로세스 상태)

- 프로세서 관점으로 볼 때 프로세서는 프로그램  카운터 레지스터(PC register)값에 의해 결정된 순서에 따라 명령어를 수행함
- Trace(실행 궤적)
    - 해당 프로세스에 대해 실행되는 명령어의 리스트. sequence of instructions that execute for that process
    - 프로세서의 실행의 특징은 다양한 프로세스들의 trace가 어떻게 인터리빙되는지를 보임으로써 특징지을 수 있음
- Dispatcher
    - 처리기를 한 프로세스로부터 다른 프로세스로 교체해주는 프로그램

![Screen Shot 2022-04-06 at 1.51.31 AM.png](Process%20De%2064035/Screen_Shot_2022-04-06_at_1.51.31_AM.png)

![Screen Shot 2022-04-06 at 1.52.14 AM.png](Process%20De%2064035/Screen_Shot_2022-04-06_at_1.52.14_AM.png)

- 어둡게 나타난 부분은 디스패처
- 프로세스 B가 4개 명령어 실행하고 IO 요청한다고 가정

### Two-State Process Model

- 프로세스는 Not Running 또는 Running, 두 가지 상태 중 하나를 가짐.
- 정상 종료든 비정상 종료든 Queue에 들어가게 되고 대기하다가 순서따라 프로세서에 들어가 Run한다

![Screen Shot 2022-04-06 at 1.56.28 AM.png](Process%20De%2064035/Screen_Shot_2022-04-06_at_1.56.28_AM.png)

## 프로세스 생성과 종료

### 프로세스 생성 이유

| New batch job(새로운 일괄처리 작업) | 일괄처리 환경에서 작업이 제출될 때 프로세스 생성 |
| --- | --- |
| Ineractive logon(대화형 로그온) | 새로운 사용자가 터미널에 로그온할 때 |
| 서비스를 제공하기 위해 운영체제가 생성 | 사용자가 대기할 필요 없도록 어떤 기능을 수행할 프로세스를 생성해줌 |
| 기존 프로세스에 의한 생성(spawn) | 모듈화를 위해서, 병렬성을 이용하기 위해서 사용자 프로그램이 프로세스 생성을 명령함 |

### 프로세스 생성(Spawn, not creation)

- Process Spawning
    - 운영체제가 어떤 프로세스의 명시적인 요청에 의해 새로운 프로세스를 생성하는 것
- Parent process
    - 다른 프로세스를 생성하는 프로세스
- Child process
    - 만들어진 프로세스
    

### 프로세스 종료 이유

![IMG_8204.HEIC](Process%20De%2064035/IMG_8204.heic)

첫번째: 정상종료

뒤에서 두개: 부모에 의해

나머지: 오류, 이벤트성

### 프로세스 종료

- 프로세스가 완료되었음을 나타내는 수단이 있어야함
- batch job(일괄 작업)에는 종료를 위한 halt 명령이나 명시적 os서비스 호출이 있어야함
- interactive application(대화형 프로그램)의 경우 사용자의 작업은 프로세스가 완료될 때 표시됨

### Five-State Process Model

![Screen Shot 2022-04-06 at 2.12.02 AM.png](Process%20De%2064035/Screen_Shot_2022-04-06_at_2.12.02_AM.png)

- Two-State Model에서는 Not Running상태의 프로세스들 중 준비가 되지 않은 친구들이 있을 수 있다.
- 그래서 block되지 않았으며 큐에 가장 오래된 아이를 뽑기 위해 나온 모델
- Not Running 상태를 Ready상태와 Blocked상태로 분할
- 5가지 상태
    - Running
        - 현재 수행 중인 프로세스.
    - Ready
        - 기회가 주어지면 수해오딜 준비가 되어 있는 프로세스
    - Blocked/Waiting
        - 입출력 연산 완료와 같은 어떤 이벤트가 발생할 때까지 수행될 수 없는 프로세스
    - New
        - 막 생성되어서 ready에 진입이 허용되지 않은 프로세스
        - 보통 pcb가 생기더라도 바로 메모리에 올라가지 않음
    - Exit
        - 프로세스 수행이 halt(중지) 되거나 어떤 이유로 abort(중단)되었기때문에 운영체제에 의해 수행가능 프로세스 풀에서 방출된 프로세스
- 프로젝트의 규모가 커지면 blocked queue를 하나만 두는 것보다 이벤트 별로 나눌 수 있는데 그것이 Multiple blocked queues(↔ single blocked queue)
    
    ![Screen Shot 2022-04-06 at 2.17.11 AM.png](Process%20De%2064035/Screen_Shot_2022-04-06_at_2.17.11_AM.png)
    

### Suspended Processes(보류된 프로세스)

- Swapping
    - 필요한 이유
        - 입출력 장치가 너무 느리기 때문에 프로세서의 대부분의 시간이 idle(유휴)해버리기 때문에
        - idle한 아이들을 빼고 다른 아이들을 돌리기 위해 메모리에 더 올리려면 더 큰 메모리 공간이 필요해버리는데 불필요하다
    - 메인 메모리에서 디스트로 모든 프로세스의 일부나 전체를 옮기는 것
    - 메모리에 있는 프로세스 중에 ready 상태가 하나도 없으면 os는 블록된 프로세스들 중에 하나를 디스크로 내보내고 suspend queue(보류 큐)에 집어넣어버림
    - suspend queue에는 메모리로부터 잠시 쫒겨진 프로세스들이 존재
    - 메모리에 공간이 생겼으므로 보류큐에 있는 다른 프로세스를 메모리로 들이거나 새로운 프로세스 요청을 받아들이고 run함
    - swapping 자체가 io작업이므로 문제가 더 악화될 수도 있음.  하지만 swapping에 사용되는 disk io가 가장 빠른 io기때문에 괜찮을거야~
    
- one suspend state
    - suspend만 추가
- Two suspend States
    - ready: 프로세스 메모리에 있고 바로 수행 가능
    - blocked: 메모리에 있고 이벤트 기다리는 애
    - blocked/suspend: 프로세스가 보조기억장치에 있고 이벤트 기다리는 애
    - ready/suspend: 프로세스가 보조기억장치에 있지만 메모리로 올라가면 바로 수행될 수 있음
    

## Process Description(프로세스 기술)

### 운영체제 제어 구조

- 운영체제가 프로세스와 자원들을 관리하기 위해서는 이들 각가에 대한 현재 상태를 나타내는 정보를 가지고 있어야함
- 이를 위해 관리하고자 하는 각 개체에 대한 정보를 테이블로 구성해서 유지
- 운영체제가 제어해야할 서로 다른 4가지 타입(테이블로 가지고 있음)
    
    ![Screen Shot 2022-04-06 at 1.32.07 PM.png](Process%20De%2064035/Screen_Shot_2022-04-06_at_1.32.07_PM.png)
    
    - 메모리
    - 입출력 장치
    - 파일
    - 프로세스

### 메모리 테이블

- 메모리와 보조기억장치 모두의  track을 유지하기 위해 사용됨
- 메모리 일부는 OS가 사용하도록 예약되어 있고, 나머지는 프로세스들이 사용할 수 있음
- 프로세스들은 가상 메모리나 간단한 스와핑 기법을 사용하여 보조기억장치 내에 유지되기도 함
- 메모리 테이블이 가지고 있어야 하는 정보
    - 프로세스에게 할당된 메모리
    - 프로세스에게 할당된 보조 기억 장치
    - 어떤 프로세스가 특정 공유 메모리 영역에 접근 가능하다는 속성 등과 같은 메모리나 가상메모리 블록들에 대한 보호 속성(프로세스가 특정 영역 접근 가능?)
    - 가상 메모리를 관리하기 위해 필요한 정보

### 입출력 테이블

- 입출력 장치와 컴퓨터 시스템의 채널들을 관리하기 위해 운영체제에서 사용됨
- 입출력 동작 진행 중일 때 OS는 입출력 동작의 진행 상태와 입출력 전송의 풀발지와 목적지로서 사용되는 주기억장치 내의 위치를 알아야함

### 파일 테이블

- 저장된 정보
    - 파일의 존재 여부
    - 보조기억장치에 저장된 파일의 위치
    - 현재 상태
    - 그 밖의 속성에 대한 정보 저장(속성값 등(read가능해))
- OS는 파일에 대해서 거의 모름
    - 어떤 운영체제는 파일 관리의 대부분을 OS에서 하기도 함

### 프로세스 테이블

- 프로세스 관리를 위해 유지됨
- 직간접적으로 메모리, I/O, 파일에 대한 참조가 있어야함(위의 테이블들은 모두 프로세스테이블을 위한 것~)
- OS가 처음에 테이블들을 생성할지 어떻게 알고 있지?
    - OS가 메모리 용량, io 장치 현황, 어떻게 식별할 수 있는지 등 기본 정보를 할고 있어야함
- 테이블 자체는 OS에서 엑세스 할 수 있어야하므로 메모리 관리 대상임

## 프로세스 제어 구조

### 프로세스 관리를 위해 OS가 알아야할 것들

- 위치: 프로세스가 어디 있는지
- 프로세스의 속성: 프로세스ID(PID), 프로세스 상태 등을 알아야 관리할 수 있음

### Process Location(프로세스 위치)

- 프로세스는 실행할 프로그램이나 프로그램의 집합을 포함해야함
- 프로세스는 해당 프로세스의 프로그램과 데이터를 보유하기에 충분한 메모리로 구성됨
- 프로그램 실행은 보통 프로시저 호출들의 track과 프로시저 사이의 매개변수를 유지하는데 사용되는 스택을 포함함

### Process Attributes(프로세스 속성)

- OS는 해당 프로세스를 제어하기 위해 속성들을 사용함
- 속성들의 집합을 PCB(Process Control Block)라고 함
- 프로그램과 데이터, 스택, 속성들의 집합을 프로세스 이미지(Process image)라고 함

### Process Image의 원소

- User Data
    - 사용자 공간에서 수정 가능한 부분, 프로그램 데이터와 사용자 스택 영역, 수정될 수 있는 프로그램 포함
- User Program
    - 실행할 프로그램
- Stack
    - 각 프로세스는 하나 이상의 시스템 스택을 가짐.
    - 스택은 프로시저와 시스템 호출에 필요한 매개변수와 호출 수조(복귀 주소)를 저장하는데 사용됨
    - → 파라미터 저장, 필요한 데 사용
- PCB(Process Control Block)
    - 프로세스를 제어하기 위해 운영체제가 필요로 하는 데이터
    - 속성값들을 보유

## 프로세스 속성

### PCB 내에 있는 정보들의 범주

- 프로세스 식별
- 프로세스 상태 정보
- 프로세스 제어 정보

### 프로세스 식별(Process identification)

- Identifier(식별자)
    - PCB에는 아래와 같은 숫자로 된 식별자가 존재
        - 이 프로세스의 식별자
        - 이 프로세스의 부모 프로세스 식별자
        - 사용자 식별자

### 처리기 상태 정보(Processor State Information)

- User-Visible Registers(사용자가 사용 가능한 레지스터)(General Purpose Register)
    - 프로세서가 사용자 모드에서 수행하는 기계 언어에 의해 참조될 수 있는 레지스터.
- Control and Status Register(제어 레지스터 & 상태 레지스터)
    - PC(Program Counter)
        - 다음에 반입(fetch)할 명령어의 주소를 가짐
    - condition codes(조건 코드)
        - 가장 최근에 수행된 산술 또는 논리 연산의 결과
    - Status Information(상태 정보)
        - 인터럽트 가능/불가 플래그들과 수행 모드(커널 or 유저)를 가짐
- Stack Pointer
    - 각 프로세스는 하나 이상의 스택을 가짐
    - 스택이 저장하는 것
        - 프로시저
        - 시스템 호출의 매개변수와 호풀 주소
        
        스택 포인터는 스택의 top을 가리킴
        

### 프로세스 제어 정보(Process Control Information)

- Scheduling and State Information
    
    운영체제가 스케줄링 기능을 수행하기 위해 필요한 정보들
    
    - Process State(프로세스 상태)
        - 수행되기 위해 스케줄될 프로세스의 준비상황
        - running, ready, waiting, halted
    - Priority
        - 프로세스의 스케줄링 우선순위를 나타내기 위해 하나 이상의 필드가 사용됨
        - 여러 개의 값이 요구될 수 있음(기본값, 현재값, 허용가능 최대치)
    - Scheduling-related information(스케줄링과 관련된 정보)
        - 프로세스가 대기하고 있었던 시간, 마지막에 수행되었던 시간 등
    - Event
        - 프로세스가 재시작되기 전에 기다리고 있던 사건을 알려줌
        - 그럼 PC랑 뭐가 다르니?
- Data Structuring(자료구조화)
    - 프로세스는 큐, 링 혹은 다른 자료구조로 다른 프로세스와 연결될 수 있음(부모 자식 구조와 같이)
    - 다른 프로세스를 가리키는 포인터를 지원
- Interprocess Communication(IPC, 프로세스간 통신)
    - 여러 플래그와 시그널, 메시지 등이 독립된 두 개의 프로세스 사이의 통신과 연관될 수 있음.
    - 이 정보의 일부 혹은 전부가 PCB 내에 유지됨
- Process Privileges(프로세스 권한)
    - 프로세스가 어디까지 접근 가능한지, 어떤 instruction까지 실행이 간으한지 권한
- Memory Management
    - 프로세스에 할당된 것들(가상메모리를 나타내는 세그먼트, 페이지 테이블)에 대한 포인터 가짐
- Resource Ownership and Utilization(자우너의 소유권과 이용률)
    - 프로세스가 제어하는 자원들을 파일처럼 표시될 수 있음
    - 이용률에 대한 이력 정보 또한 가지고 있음.
    - 이 정보들은 스케줄러에 의해 사용됨
    

## PCB의 역할

- 운영체제에서 가장 중요한 자료구조
- 운영체제에게 필요한 모든 정보들이 들어있음
- 운영체제의 모든 모듈에 의해 읽혀지고 수정될 수 있음
- PCB의 집합은 운영체제의 상태를 정의한다
- PCB들을 PID로 구별한다.
    
    ![Screen Shot 2022-04-08 at 5.20.48 PM.png](Process%20De%2064035/Screen_Shot_2022-04-08_at_5.20.48_PM.png)
    
- virtual memory에서의 프로세스들의 구조는 연속해서 보이지만 물리적인 공간은 사실 분리되어 있다.

## 프로세스 제어

### 수행 모드

- User Mode
    - 권한 낮음
    - 일반적으로 user program들이 이 모드로 수행됨
- Kernel Mode
    - 시스템 모드, 제어 모드 등으로 불림
    - 더 높은 권한
    - 운영체제 커널과 관련
    

### 운영체제 커널의 기능

- Process Management
    - 프로세스 생성과 종료
    - 프로세스 스케줄링과 디스패칭
    - 프로세스 교환
    - 프로세스 동기화와 프로세스 간 통신 지원
    - PCB 관리
- Memory Management
    - 프로세스에 주소 공간 할당
    - 스와핑
    - 페이지와 세그먼트 관리
- I/O Management
    - 버퍼 관리
    - 프로세스에 입출력 채널과 장치 할당
- Support Functions(지원 기능)
    - 인터럽트 핸들링
    - 어카운팅
    - 모니터링

### 프로세스 생성

1. 새로운 프로세스를 위해 PID(프로세스 식별자) 할당. 
    - 이때, 새로운 항목이 주요 프로세스 테이블에 추가됨. 프로세스 테이블은 프로세스마다 하나의 항목을 유지함
2. 프로세스를 위한 공간 할당.
    - 프로세스 이미지의 모든 요소들이 여기에 저장.
3. PCB 초기화
    - PID 부분에는 해당 프로세스의 ID와 부모 프로세스의 ID가 들어감
    - 프로세스 상태 정보는 대부분 0으로 초기화
        - PC는 프로그램 진입점으로, 스택 포인터는 프로세스 스택 경계로 초기화
    - 프로세스 제어 정보는 표준 기본 값과 프로세스 위해 요청된 속성에 근거하여 초기화
    - 자원에 대한 명시적 요청 없으면 자원(io장치, 파일 등)을 소유하지 않게 됨
4. 프로세스가 어떤 링크에 들어가야 하는지 세팅
    1. 레디큐, 러닝큐 등등..
5. 다른 자료구조 생성

### 프로세스 교환

- 프로세스 교환을 일으키는 사건들은 어떤 것이 있을까?
- 모드 전환과 프로세스 교환의 차이는?
- 프로세스를 교환하기 위해서 OS자신이 제어하는 여러 자료구조를 어떻게 다룰까?

### 프로세스 교환 시점

- OS가 현재 수행 중인 프로세스로부터 제어를 넘겨받을 때마다 프로세스 교환 발생
- 제어는 언제 넘어감? → 인터럽트 일어날 때

| 기법 | 원인 | 사용 |
| --- | --- | --- |
| 인터럽트 | 현재 명령어 수행의 외부(I/O) | 비동기적인 외부 사건에 반응 |
| 트랩 | 현재 명령어 수행과 관련(예외처리) | 오류나 예외상황 처리 |
| 수퍼바이저 호출 | 명시적 요청 | 운영체제 기능에 대한 호출 |

- 인터럽트
    - 현재 수행 중인 프로세스와 독립적으로 외부에서 유발되는 여러 종류의 사건에 의해 발생(io)
    - 종류
        - 클럭 인터럽트
            - time slice를 다 사용해서. 시간초과
        - 입출력 인터럽트
            - 발생된 입출력 행위가 하나 이상의 프로세스가 대기하던 친구라면 대기하던 친구들때문에 블록되어있던 모든 프로세스를 준비상태로 바꾸고, 현재 수행하고 있는 프로세스를 계속 진행할지 우선순위로 인해 다른 애로 갈아탈지 결정
        - 메모리 폴트(메모리 부재)
            - 메모리에 프로세스가 접근했는데 프로세스 정보가 보조기억장치에 스왑된 경우 다시 올려줘야함.
            - 메모리 블록을 가져오기 위한 입출력 요청 후 메모리 폴트 유발시킨 프로세서 block시킴
            - 또 사른 프로세스를 수행시키기 위해 프로세스 교환 수행
            - 원하던 블록이 메모리로 적재되면 메모리 폴트를 유발시킨 프로세스 준비상태로
- 트랩
    - 불법적인 파일 접근 시도처럼 현재 수행되고 있는 프로세스에서 생성되는 오류나 예외 조건때문에 발생
    - 관련 오류나 예외 상황이 치명적인지 판단
        - 치명적
            - 현재 수행되고 있는 프로세스 종료 상태로 전이
        - 안 치명적
            - 복구 프로시저 실행하거나 사용자에게 통보
- 수퍼바이저 호출
    - ex) 사용자 프로세스가 수행 중에 파일 개방과 같은 입출력 동작을 요구하는 명령을 수행하면, 일련의 방식으로 제어를 넘기게 되고, 이 호출로 인해 해당 사용자 프로세스는 블록 상태로 전이

### 모드 전환(Mode Switching)

- 프로세서는 인터럽트 시그널 존재 여부를 가지고 인터럽트가 발생되었는지 검사.
    - 대기하고있는(pending) 인터럽트가 없다면 처리기는 반입 단계를 계송 수행하고 현재 프로세스가 수행시키고 있는 프로그램의 다음 명령어 가져옴
    - 대기하고 있는 인터럽트 있다면
        1. PC의 값을 인터럽트 행들러 프로그램의 시작 주소로 설정
        2. 사용자 모드를 커널 모드로 전환해서 인터럽트 처리 코드가 특권 명령어를 수행할 수 있도록 함
        - 여기서 프로세스는 반입 당꼐 계속 수행해서 인터럽트 처리하는 인터럽트 핸들러 프로그램의 첫번째 명령 가져옴.
        - 인터럽트된 프로세스 문맥은 인터럽트 된 프로그램의 PCB에 저장됨
        

### 프로세스 상태 변경(Change of Process State)(프로세스 전환)

![Screen Shot 2022-04-09 at 12.11.13 AM.png](Process%20De%2064035/Screen_Shot_2022-04-09_at_12.11.13_AM.png)

- 프로세스 전환은 모드 전환과 완전히 다른 개념
- 프로세스 전환은 현재 수행 상태인 프로세스가 다른 상태(ready, block 등)로 전이되면 OS가 환경을 크게 변경시켜야함
    - 모드 전환은 현재 run 상태의 프로세스 상태 바꾸지 않고 수행. 이때는 문맥 저장하거나 나중에 복구할 때 생기는 오버헤드 거의 X
- 프로세스 교환 순서
    1. 프로세스 문맥(PC와 다른 레지스터들을 포함)을 저장
    2. 현재 running state인 프로세스의 PCB 업데이트.
        - 이때 그 프로세스는 ready, block, ready/suspend, halt 상태 중 하나로 전이
    3. 프로세스의 PCB를 적절한 큐로 이동(running → 다른 곳)
    4. 다음에 수행시킬 프로세스 선택
    5. 선택된 프로세스의 PCB 갱신
        - 이때 프로세스 상태 running으로 전이
    6. 메모리 관리와 관련된 자료구조 갱신
    7. 선택된 프로세스가 이전의 running 상태에서 사용했던 프로세서의 문맥 복원
        - 이전에 저장한 처리기 문맥을 처리기로 적재하는 것 의미
    

## OS의 실행(Execution of the Operating System)

### 운영체제와 사용자 프로세스의 관계

- 분리된 커널
    - 모든 프로세스의 외부에서 Os 커널을 수행시킴
- 운영체제 기능이 사용자 프로세스 내에서 수행
    - 운영체제가 n개의 프로세스 이미지를 관리
    - 각 이미지에는 우리가 아는 이미지 구성 요소 뿐만 아니라 커넣 프로그램을 위한 프로그램, 데이터, 스택 영역까지 포함됨
        
        ![Screen Shot 2022-04-09 at 12.30.27 AM.png](Process%20De%2064035/Screen_Shot_2022-04-09_at_12.30.27_AM.png)
        
        - 그것이 이것이다!
        - private user address space까지가 우리가 아는 프로세스 이미지
        - 거기에 kernel stack과 shared address space가 추가됨
        - kernel stack
            - 프로세스가 커널 모드에 있는 동안에 수행한 호출과 복귀를 관리하기 위해 다른 영역과 분리됨
        - Shared Address Space
            - 운엉체제 코드와 데이터가 shared address space에 있어서 모든 사용자 프로세스에게 공유됨
    - 인터럽트 호출이 발생하면 프로세서는 커널모드로 전이해서 운영체제로 제어가 넘어가고 모드 전환이 일어나지만 수행은 여전히 현재 사용자 프로세스 내에서 계속됨
    - → 프로세스 교환 일어나지 않음. 프로세스 내에서 모드 전환만 일어남
- 운영체제 기능이 분리된 프로세스로 수행

## UNIX SVR4 프로세스 관리

### 프로세스 상태

- User Running
- Kernel Running
- Ready to Run, in Memory
    - 메모리 상의 준비
    - 커널이 이 프로세스를 스케줄하자마자 수행 가능
- Asleep in Memory
    - 블록 상태
    - 주 기억장치에 있음
    - 사건이 발생할 때까지 수행될 수 없음
- ㄱReady to Run, Swawpped
    - ready suspend
    - 프로세스는 run준비됐지만 스와퍼가 메모리로 스왑인해줘야함
- Sleeping, Swapped
    - block suspend
    - 프로세스가 이벤트를 기다리던 중 보조기억장ㅊㅣ로 스왑아웃됨
- Preempted
    - ready
    - 선점
    - 프로세스가 커널 모드에서 사용자 모드로 복귀하는 중에 커넣이 그 프로세스를 선점하고 다른 프로세스를 스케중하기 위해 프로세스 교환을 수행함
- Created
    - 프로세서가 새로 생성되었지만 아직 수행 준비가 안됨
- Zombie
    - 프로세스가 더 이상 존재하지는 않지만 부모프로세스가 수집할 정보를 가지고 있음

![Screen Shot 2022-04-09 at 12.47.37 AM.png](Process%20De%2064035/Screen_Shot_2022-04-09_at_12.47.37_AM.png)

### UNIX 프로세스 이미지

- 사용자 수준 문맥
    - 프로세스 텍스트
        - 프로그램에서 수행 가능한 기계 명령어
    - 프로세스 데이터
        - 이 프로세스의 프로그램이 접근할 수 있는 데이터
    - User Stack
        - 사용자 모드에서 수행되는 함수의 인자와 지역 변수, 포인터를 보유
    - 공유 메모리
        - 다른 프로세스와 공유하는 메모리
        - 프로세스간 통신에 이용됨
- 레지스터 문맥
    - PC
        - 다음에 수행될 명령어 주소
    - Processor status register(프로세서 상태 레지스터)
        - 선점될 때의 하드웨어 상태를 보유
    - Stack Pointer
        - 특정 시점의 연산 모드에 따라 커넣이나 사용자 스택의 정상을 가리킴
    - Grneral-purpose registers(범용 레지스터)
- 시스템 수준 문맥
    - Process table entry
        - 항상 주기억장치에 존재 → OS가 항상 접근 가능
        - 프로세스 status 정의
    - U(user) area
        - 프로세스 문맥에서만 접근할 필요가 있는 프로세스 제어 정보
    - Per process region table(프로세스 당 영역 테이블)
        - 가상 주소를 물리 주소로 사상하는 방식을 정의
    - Kernel stack
        - 프로세스가 커넣 모드에서 수행될 때 커넣 프로시저의 스택 프레임을 포함
        

### UNIX 프로세스 테이블 항목

![IMG_8228.heic](Process%20De%2064035/IMG_8228.heic)

### UNIX U Area

![IMG_8229.heic](Process%20De%2064035/IMG_8229.heic)

### UNIX 프로세스 제어

- UNIX에서 프로세스는 커널 시스템 호출인 fork()를 통해 생성됨
- 어떤 프로세스가 fork요청을 하면 다음과 같은 순서로 작업을 수행
    1. 새로 생성될 프로세스를 위해 프로세스 테이블에 한 slot을 할당
    2. 자식 프로세스에게 PID 할당
    3. 공유 메모리를 제외하고 부모의 프로세스 이미지 복사
    4. 부모 프로세스가 소유하고 있는 모든 파일들의 counter을 증가치켜 자식 프로세스도 그 파일들을 소유하게 되었음을 알림
    5. 자식 프로세스를 준비 상태로 설정
    6. 부모 프로세스에서는 자식 프로세스의 PID를, 자식 프로세스에게는 0을 반환
- 이 모든 작업은 부모 프로세스의 커널 모드에서 이루어짐.
- 모두 마치면 dispatch루틴의 일부로 다음 중 하나를 수행
    1. 부모 프로세스에 제어를 넘겨줌
        - 제어는 부모프로세스가 fork를 호출한 지점의 사용자 모드로 복귀
    2. 자식 프로세스에게 제어를 넘겨줌
        - 자식 프로세스는 부모 프로세스와 같은 코드 지점, 즉 fork 호출로부터 복귀된 지점에서 수행 시작
    3. 다른 프로세스에게 제어를 넘겨줌
        - 부모와 자식 프로세스 모두 ready상태에 남겨짐

## 요약

- 운영체제의 주요 기능은 프로세스를 생성, 관리, 종료 시키는 것
- 프로세스가 활성화되있는 동안 OS는 각 프로세스가 처리기에 의해 수행된 시간을 알아야하고, 프로세스들의 활동을 조정하고, 서로 상반되는 요구를 처리하고, 프로세스들에게 시스템 자원을할당
- 프로세스 관리 기능을 수행하기 위해 OS는 각 프로세스의 description(프로세스 이미지와 PCB)를 유지
- 프로세스 이미지에는 프로세스가 수행되는 주소 공간이 포함됨
- PCB에는 OS가 프로세스를 관리하는데 필요한 모든 정보가 유지
    - 정보: 프로세스의 현재 상태, 프로세스에 할당된 자원, 우선순위 및 그 밖의 관련된 데이터
- 프로세스가 생존하는 동안 프로세스는 여러 다른 상태 사이클을 이동
- 수행 중인 프로세스는 인터럽트에 의해 또는 OS의 수퍼바이저 호출을 수행함으로써 인터럽트됨
- 인터럽트: 프로세스 외부에서 발생되는 사건으로 처리기에 의해 인지
- 무조건 처리기는 모드 전환을 수행하여 제어를 운영체제 루틴에게 넘겨줌
- OS는 필요한 작업을 완료한 후 인터럽트된 프로세스를 재개시키걷나 다른 프로세스로 교환됨