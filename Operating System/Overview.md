# Overview

# 운영체제(Operating System)

- 응용 프로그램의 실행을 제어하고 응용프로그램과 컴퓨터 하드웨어 간의 인터페이스 역할을 하는 프로그램.
- 3가지 목표(objectives)
    1. Convenience: 편의성
    2. Efficiency: 효율성
    3. Ability to evolve: 진화 능력
- 컴퓨터에서 실행되는 사장 중요한 소프트웨어
- 없으면 컴퓨터 쓸모 없어요!
- 소프트웨어와 하드웨어 전부 관리한다.
- 여러 다른 프로그램 동시에 실행 가능, cpu, main memory, IO devices등등에 접근 가능

## 기본 구성 요소

- Processor(프로세서, 처리기)
    - 컴퓨터 동작을 제어, 데이터 저리
    - 하나만 있는 경우 CPU(중앙 처리 장치)라고 부름
- Main memory(주기억장치)
    - 데이터와 프로그램 저장
    - 휘발성(volatile)
    - real memory, primary memory라고도 불림
- I/O Modules(입출력 모듈)
    - 컴퓨터와 외부 환경 간의 데이터 이동을 담당
    - 보조기억장치, 통신장비, 단말기등 포함
- System Bus
    - 위의 구성 요소 간의 통신을 제공
    

## 명령어 수행

- 프로그램은 프로세서에 의해 수행되며, 메모리에 저장된 명령어들의 집합으로 구성됨
- 아래의 반복으로 수행됨
1. instruction fetch(명령어 반입): 프로세서가 메모리에서 명령어를 읽음
    1. 명령어 사이클이 실행될 때 프로세스는 메모리로부터 명령어 가져옴
    2. PC(프로그램 카운터)가 다음에 가져올 명령어의 주소를 가지고 있음
    3. PC를 증가지켜 순서대로 다음 명령어가 반입되게 함
2. instruction execution(명령어 실행): 프로세서가 각 명령 실행
    1. 반입된 명령어는 프로세서 내 IR(instruction register,명령어 레지스터)로 적재됨
    2. 명령어는 프로세서가 행해야할 작업을 명시

## 인터럽트(Interrupt)

- 다른 모듈(i/o, 메모리)이 프로세서의 정상적인 순서를 방해할 수 있는 메커니즘
- 프로세서의 효율성을 높이기 위해 사용됨
    - 대부분의 I/O 장치가 프로세서보다 느림
    - 프로세서는 장치가 완료될 때까지 기다려야함
        - 이게 길어질 수도 있음
    - 프로세서의 낭비가 이뤄질 수 있음

### 인터럽트의 부류

- Program(프로그램): 산술 연산 오버플로, 0으로 나누기, 불법적인 기계 명령어 수행 시도, 사용자에게 허용된 메모리 공간 밖의 참조등과 같은 명령어 수행 결과로 방생하는 어떤 조건에 의해 생성
- Timer(타이머): 프로세서 내의 타이머에 의해 생성. 운영체제로 하여금 특정 기능을 정기적으로 수행할 수 있게 함
- I/O: I/O 컨트롤러에 의해 생성되며 연산의 정상적인 종료를 알리거나 다양한 에러 조건을 알림
- Hardware Failure(하드웨어 실패): 전원 결함 또는 메모리 패러티 에러와 같은 결함에 의해 생성

### 인터럽트의 유무에 따른 제어 흐름

- 예: 1s에 10억개로 동작하고, 7200rpm, 즉 1분에 7200번 회전하는 디슽크가 있다고 생각하면 반 바퀴를 도는데 걸리는 시간은 (60s/7200) * 1/2 = 4.17ms가 걸리게 된다. 이는 처리기에 비해 400만배 느린 것.
- 인터럽트가 없으면 IO프로그램을 실행시키고 프로그램은 기다려야한다.
- 인터럽트가 있다면 IO프로그램을 시키고 계속 진행하다가 interrupt handler가 플래그를 날리면(인터럽트 요청 신호를 프로세서로 보내면) 다시 가서 진행을 하고 다시 진행을 하면 돼서 효율적이다.
- 만약 긴 입출력 대기가 필요하다면 IO모듈을 사용해야하는 시점이 첫번째 IO 프로그램 사용의 끝보다 빨리 찾아오면 기다리게 된다.

### 인터럽트와 명령어 사이클

![Screen Shot 2022-04-05 at 5.46.44 PM.png](Overview%2099c13/Screen_Shot_2022-04-05_at_5.46.44_PM.png)

- 제어흐름에 인터럽트 단계가 추가됨
- 프로세서가 인터럽트 발생 여부를 체크함
- 인터럽트를 통해 약간의 오버헤드가 생기긴 하지만 입출력 연산이 완료되기를 기다리며 낭비라는 시간이 더 크기 때문에 인터럽트를 사용하면 프로세서를 더 효율적으로 사용할 수 있다

### 인터럽트 처리

- 인터럽트 발생으로 프로세서 하드웨어와 소프트웨어에서 많은 이벤트가 발생하게 되는데 순서는 다음과 같음

![Untitled](Overview%2099c13/Untitled.png)

1. 장치가 인터럽트 시그널을 처리기로 보냄
2. 인터럽트가 응답하기 전에는 프로세서는 현재 수행 중인 명령어를 계속 진행
3. 프로세서가 대기 중인 인터럽트 요청이 있는지 검사하며 알게 되고, 인터럽트를 방생기킨 장치에게 수신 확인 신호를 보냄
4. 처리기가 제어를 인터럽트 루틴으로 넘기기 위한 준비가 필요함.
    1. 인터럽트가 발생한 시점에서 현재 진행 중인 프로그램을 재개하는데 필요한 정보를 저장해야함.
    2. PSW(program status word)에 메모리 사용 정보등을 저장하고, PC(프로그램 카운터 안에 있는 내용) 등을 저장
5. 프로세서가 발생한 인터럽트에 응답할 진입 위치를 PC값에 적재.
6. 인터럽트 당한 프로그램과 고나련 있는 PC와 PSW는 제어 스택에 보관되어있음.
그리고 추가로 저장해야하는 프로세서 레지스터의 내용을 스택에 저장
7. 인터럽트 처리
8. 처리가 오나료되면 저장된 레지스터 값 검색하여 레지스터에 다시 저장
9. 스택에 저장해둔 PSW와 PC를 복구하면 기존에 실행되던 위치부터 다시 실행 가능

### 중첩 인터럽트(Multiple Interrupt)

- 인터럽트가 중복해서 발생한다면?
    - ex) 통신에서 데이터 수신과 동시에 결과를 출력하라고 한다면?
- 두가지 처리법
    1. 인터럽트가 처리되는 동안 다른 애들 못 오게 비활성화
        1. 들어온 순서대로 하나 끝내고 처리
    2. 우선순위 제공
    

## 메모리 계층 구조(Memory Hierarchy)

- 계층 구조 아래로 갈수록
    - 비용 감소
    - 용량 증가
    - 접근시간 증가
    - 접근빈도 감소

상위 계층부터

- Inboard Memory
    - 레지스터
    - 캐시
    - 메인 메모리
- Outboard Memory
    - 자기 디스크
    - cd-rom
    - cd-rw
    - dvd-rw
    - dvd-ram
    - blu-ray
- Off-line Storage
    - 자기테이프

### 메모리 성능 비교

2가지 메모리가 있다고 가정하고 

- L1은 1000바이트, 0.1us 접근시간
- L2는 100000바이트, 1us 접근시간을 가진다고 가정
- 메모리 평균 접근 시간을 hit-rate(적중률) 함수로 나타내고
- L1에 95%가 적중한다고 하면(H=0.95)
- (0.95)(0.1us) + (0.05)(0.1us+1us) = 0.095 + 0.055 = 0.15us

→  L1에 필요한 애가 있을 확률이 클수록 L2까지 가지 않아도 되므로 점점 시간이 T1의 시간과 근사하게 됨 

→ L1에서 최대한 히트되게 해야한다

### 지역성의 원리(Principle of Locality)

- 프로세서에 의한 메모리 참조는 프로그램 실행 과정에서 클러스터를 형성하는 경향이 있다

→ 클러스터를 L1에 두면 좋다

- 데이터는 하위 레벨 메모리의 엑세스 비율이 상위 레벨보다 작도록 구성해야한다.

## 캐시 메모리(Cache Memory)

- 프로세서 실행은memoey cycle time에 의해 제한됨
- 프로세서는 명령당 최소 한 번 메모리에 접근해야함
- 속도, 비용, 크기 간의 균형을 위해 프로세서와 메인 메모리 사이에 캐시를 두어 지역성의 원리를 활용함
- OS에 보이지 않음
- 캐시를 여러개 두면 더 좋음

### 캐시의 원리

- 이용 가능한 가장 빠른 메모리의 속도에 근접한 메모리를 제공하는 동시에 비용이 저렴한 대용량의 메모리를 제공하는 것이 목적
    
    ![Screen Shot 2022-04-05 at 6.34.28 PM.png](Overview%2099c13/Screen_Shot_2022-04-05_at_6.34.28_PM.png)
    
- 

## 멀티 프로세서와 멀티코어 구조

### 대칭형 멀티 프로세서(Symmetric Multiprocessor Organization)

- 특징
    - 두개 이상의 유사한 수행 능력을 갖는 프로세서로 구성
    - 버스나 다른 내부 연결 방식에 의해 상호 연결된 주기억장치와 I/O장치를 공유함. → 각 프로세서들이 메모리에 접근하는 시간은 거의 동일
    - 동일한 장치에 이르는 경로들을 제공하는 채널이 동일하거나 달라도 모든 프로세서는 I/O장치 접근을 공유함
    - 모든 프로세서는 동일한 기능을 수행할 수 있음
    - 시스템은 프로세서들과 작업, 태스크, 파일, 데이터 요소 수준에서 크로그램들 간의 상호작용을 제공하는 하나의 통합된 운영체제에 의해 제어됨
- 단일 구조보다의 잠재적 장점
    - 성능
    - 가용성
    - 점진적 확장
    - 크기 조정
- 캐시는 공유 X
- 메인 메모리와 IO시스템을 버스를 동해 공유

### 멀티코어 컴퓨터

![Screen Shot 2022-04-05 at 6.42.40 PM.png](Overview%2099c13/Screen_Shot_2022-04-05_at_6.42.40_PM.png)

- Chip multiprocessor라고도 함
- 두개 이상의 프로세서를 하나의 다이에 올림
    - 각 코어는 독립 프로세서의 모든 요소들로 구성됨
- 멀티코어 칩에는 L2캐시도 포함되며 경우에 따라 L3캐시도 포함됨